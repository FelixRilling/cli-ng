var Clingy=function(){"use strict";class t extends Map{hasIgnoreCase(t){return Array.from(this.keys()).map(t=>t.toLowerCase()).includes(t.toLowerCase())}getIgnoreCase(t){let e=null;return this.forEach((n,s)=>{t.toLowerCase()===s.toLowerCase()&&(e=n)}),e}}var e;!function(t){t[t.ERROR=0]="ERROR",t[t.WARN=1]="WARN",t[t.INFO=2]="INFO",t[t.DEBUG=3]="DEBUG",t[t.TRACE=4]="TRACE"}(e||(e={}));let n=e.INFO;const s=console;class i{constructor(t){this.name=t}error(...t){n>=e.ERROR&&s.error(this.getPrefix("ERROR"),...t)}warn(...t){n>=e.WARN&&s.warn(this.getPrefix("WARN"),...t)}info(...t){n>=e.INFO&&s.info(this.getPrefix("INFO"),...t)}debug(...t){n>=e.DEBUG&&s.log(this.getPrefix("DEBUG"),...t)}trace(...t){n>=e.TRACE&&s.log(this.getPrefix("TRACE"),...t)}getPrefix(t){return`${(new Date).toISOString()} ${t} ${this.name} - `}}const r={level:n,getLogger:t=>new i("name"in t?t.name:t)},o=t=>null==t,a=(t,e)=>{const n=t.length;const s=e.length;if(0===n)return s;if(0===s)return n;const i=[];for(let t=0;t<=s;t++)i[t]=[t];for(let t=0;t<=n;t++)i[0][t]=t;for(let r=1;r<=s;r++){const s=i[r],o=i[r-1];for(let i=1;i<=n;i++)if(e.charAt(r-1)===t.charAt(i-1))s[i]=o[i-1];else{const t=o[i-1]+1,e=s[i-1]+1,n=o[i]+1;s[i]=Math.min(t,e,n)}}return i[s][n]},u=(t,e)=>{const n=new Map;t.forEach((s,i)=>{const r=e(s,i,t);n.set(r,n.has(r)?[...n.get(r),s]:[s])});return n},g=(t,e,n=!1)=>{const s=u(e,e=>a(t,e));return n?s:s.get(Math.min(...s.keys()))};class h{constructor(t,e){this.missing=[],this.result=new Map;const n=r.getLogger(h);n.debug("Matching arguments {} with {}",t,e),t.forEach((t,s)=>{s<e.length?(n.trace("Found matching argument for {}, adding to result: {}",t.name,e[s]),this.result.set(t.name,e[s])):t.required?(n.trace("No matching argument found for {}, adding to missing.",t.name),this.missing.push(t)):(n.trace("No matching argument found for {}, using default: {}",t.name,t.defaultValue),this.result.set(t.name,t.defaultValue))}),n.debug("Finished matching arguments: {} expected, {} found and {} missing.",t.length,this.result.size,this.missing.length)}}const l=(t,e)=>g(e,Array.from(t.keys()),!1);class c{constructor(t=!0){this.logger=r.getLogger(c),this.caseSensitive=t}resolve(t,e,n=!1){return this.resolveInternal(t,e,[],n)}resolveInternal(t,e,n,s=!1){if(0===e.length)throw new Error("Path cannot be empty.");const i=e[0],r=e.slice(1);if(n.push(i),this.caseSensitive?!t.has(i):!t.hasIgnoreCase(i))return this.logger.warn("Command '{}' could not be found.",i),{successful:!1,pathUsed:n,pathDangling:r,type:1,missing:i,similar:l(t,i)};const a=this.caseSensitive?t.get(i):t.getIgnoreCase(i);this.logger.debug("Successfully looked up command: {}",i);let u;if(!s||o(a.args)||0===a.args.length)this.logger.debug("No arguments defined, using empty list."),u=new Map;else{this.logger.debug("Looking up arguments: {}",r);const t=new h(a.args,r);if(t.missing.length>0)return this.logger.warn("Some arguments could not be found: {}",t.missing),{successful:!1,pathUsed:n,pathDangling:r,type:2,missing:t.missing};u=t.result,this.logger.debug("Successfully looked up arguments: {}",u)}const g={successful:!0,pathUsed:n,pathDangling:r,type:0,command:a,args:u};return this.logger.debug("Returning successful lookup result: {}",g),g}}class f{constructor(t=['"']){this.logger=r.getLogger(f),this.legalQuotes=t,this.pattern=this.generateMatcher()}parse(t){return this.logger.debug("Parsing input '{}'",t),Array.from(t.match(this.pattern))}generateMatcher(){this.logger.debug("Creating matcher.");const t=this.legalQuotes.map(t=>`\\Q${t}\\E`).map(t=>`${t}(.+?)${t}`);t.push("(\\S+)");let e;try{e=new RegExp(t.join("|"),"")}catch(t){throw this.logger.error("The parsing pattern is invalid, this should never happen.",t),t}return e}}class m{constructor(e=new t,n=!0,s=['"']){this.logger=r.getLogger(m),this.lookupResolver=new c(n),this.inputParser=new f(s),this.map=e,this.mapAliased=new t,this.updateAliases()}setCommand(t,e){this.map.set(t,e),this.updateAliases()}getCommand(t){return this.mapAliased.get(t)}hasCommand(t){return this.mapAliased.has(t)}hasPath(t){const e=this.getPath(t);return null!=e&&e.successful}getPath(t){return this.logger.debug("Resolving pathUsed: {}",t),this.lookupResolver.resolve(this.mapAliased,t)}parse(t){return this.logger.debug("Parsing input: '{}'",t),this.lookupResolver.resolve(this.mapAliased,this.inputParser.parse(t),!0)}updateAliases(){this.logger.debug("Updating aliased map."),this.mapAliased.clear(),this.map.forEach((t,e)=>{this.mapAliased.set(e,t);t.alias.forEach(n=>{this.mapAliased.has(n)?this.logger.warn("Alias '{}' conflicts with a previously defined key, will be ignored.",n):(this.logger.trace("Created alias '{}' for '{}'",n,e),this.mapAliased.set(n,t))})}),this.logger.debug("Done updating aliased map.")}}return m}();
//# sourceMappingURL=clingy.min.js.map
