var clingy=function(t){"use strict";class e extends Map{hasIgnoreCase(t){return Array.from(this.keys()).map(t=>t.toLowerCase()).includes(t.toLowerCase())}getIgnoreCase(t){let e=null;return this.forEach((n,s)=>{t.toLowerCase()===s.toLowerCase()&&(e=n)}),e}}var n;!function(t){t[t.ERROR=0]="ERROR",t[t.WARN=1]="WARN",t[t.INFO=2]="INFO",t[t.DEBUG=3]="DEBUG",t[t.TRACE=4]="TRACE"}(n||(n={}));let s=n.TRACE;const i=console;class r{constructor(t){this.name=t}error(...t){s>=n.ERROR&&i.error(this.getPrefix("ERROR"),...t)}warn(...t){s>=n.WARN&&i.warn(this.getPrefix("WARN"),...t)}info(...t){s>=n.INFO&&i.info(this.getPrefix("INFO"),...t)}debug(...t){s>=n.DEBUG&&i.log(this.getPrefix("DEBUG"),...t)}trace(...t){s>=n.TRACE&&i.log(this.getPrefix("TRACE"),...t)}getPrefix(t){return`${(new Date).toISOString()} ${t} ${this.name} -`}}const o={level:s,getLogger:t=>new r("name"in t?t.name:t)},a=t=>null==t,g=(t,e)=>{const n=t.length;const s=e.length;if(0===n)return s;if(0===s)return n;const i=[];for(let t=0;t<=s;t++)i[t]=[t];for(let t=0;t<=n;t++)i[0][t]=t;for(let r=1;r<=s;r++){const s=i[r],o=i[r-1];for(let i=1;i<=n;i++)if(e.charAt(r-1)===t.charAt(i-1))s[i]=o[i-1];else{const t=o[i-1]+1,e=s[i-1]+1,n=o[i]+1;s[i]=Math.min(t,e,n)}}return i[s][n]},u=(t,e)=>{const n=new Map;t.forEach((s,i)=>{const r=e(s,i,t);n.set(r,n.has(r)?[...n.get(r),s]:[s])});return n},h=(t,e,n=!1)=>{const s=u(e,e=>g(t,e));return n?s:s.get(Math.min(...s.keys()))};class l{constructor(t,e){this.missing=[],this.result=new Map;const n=o.getLogger(l);n.debug(`Matching arguments ${t} with ${e}`),t.forEach((t,s)=>{if(s<e.length){const i=e[s];n.trace(`Found matching argument for ${t.name}, adding to result: ${i}`),this.result.set(t.name,i)}else t.required||null==t.defaultValue?(n.trace(`No matching argument found for ${t.name}, adding to missing.`),this.missing.push(t)):(n.trace(`No matching argument found for ${t.name}, using default: ${t.defaultValue}`),this.result.set(t.name,t.defaultValue))}),n.debug(`Finished matching arguments: ${t.length} expected, ${this.result.size} found and ${this.missing.length} missing.`)}}const c=(t,e)=>h(e,Array.from(t.keys()),!1);class f{constructor(t=!0){this.logger=o.getLogger(f),this.caseSensitive=t}resolve(t,e,n=!1){return this.resolveInternal(t,e,[],n)}resolveInternal(t,e,n,s=!1){if(0===e.length)throw new Error("Path cannot be empty.");const i=e[0],r=e.slice(1);if(n.push(i),this.caseSensitive?!t.has(i):!t.hasIgnoreCase(i))return this.logger.warn(`Command '${i}' could not be found.`),{successful:!1,pathUsed:n,pathDangling:r,type:1,missing:i,similar:c(t,i)};const o=this.caseSensitive?t.get(i):t.getIgnoreCase(i);this.logger.debug(`Successfully looked up command: ${i}`);let g;if(!s||a(o.args)||0===o.args.length)this.logger.debug("No arguments defined, using empty list."),g=new Map;else{this.logger.debug(`Looking up arguments: ${r}`);const t=new l(o.args,r);if(t.missing.length>0)return this.logger.warn(`Some arguments could not be found: ${t.missing}`),{successful:!1,pathUsed:n,pathDangling:r,type:2,missing:t.missing};g=t.result,this.logger.debug(`Successfully looked up arguments: ${g}`)}const u={successful:!0,pathUsed:n,pathDangling:r,type:0,command:o,args:g};return this.logger.debug(`Returning successful lookup result: ${u}`),u}}class p{constructor(t=['"']){this.logger=o.getLogger(p),this.legalQuotes=t,this.pattern=this.generateMatcher()}parse(t){return this.logger.debug("Parsing input '{}'",t),Array.from(t.match(this.pattern))}generateMatcher(){this.logger.debug("Creating matcher.");const t=this.legalQuotes.map(t=>`\\Q${t}\\E`).map(t=>`${t}(.+?)${t}`);t.push("(\\S+)");let e;try{e=new RegExp(t.join("|"),"")}catch(t){throw this.logger.error("The parsing pattern is invalid, this should never happen.",t),t}return e}}class m{constructor(t=new e,n=!0,s=['"']){this.logger=o.getLogger(m),this.lookupResolver=new f(n),this.inputParser=new p(s),this.map=t,this.mapAliased=new e,this.updateAliases()}setCommand(t,e){this.map.set(t,e),this.updateAliases()}getCommand(t){return this.mapAliased.get(t)}hasCommand(t){return this.mapAliased.has(t)}hasPath(t){const e=this.getPath(t);return null!=e&&e.successful}getPath(t){return this.logger.debug(`Resolving pathUsed: ${t}`),this.lookupResolver.resolve(this.mapAliased,t)}parse(t){return this.logger.debug(`Parsing input: '${t}'`),this.lookupResolver.resolve(this.mapAliased,this.inputParser.parse(t),!0)}updateAliases(){this.logger.debug("Updating aliased map."),this.mapAliased.clear(),this.map.forEach((t,e)=>{this.mapAliased.set(e,t);t.alias.forEach(n=>{this.mapAliased.has(n)?this.logger.warn(`Alias '${n}' conflicts with a previously defined key, will be ignored.`):(this.logger.trace(`Created alias '${n}' for '${e}'`),this.mapAliased.set(n,t))})}),this.logger.debug("Done updating aliased map.")}}return t.Clingy=m,t.CommandMap=e,t}({});
//# sourceMappingURL=clingy.min.js.map
