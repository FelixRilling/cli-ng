var clingy=function(t){"use strict";const e=(t,e)=>typeof t===e,n=(t,e)=>t instanceof e,s=t=>null==t,i=t=>e(t,"string"),r=t=>n(t,Map),o=t=>!s(t)&&(e(t,"object")||e(t,"function")),a=(t,e)=>{const n=t.length;const s=e.length;if(0===n)return s;if(0===s)return n;const i=[];for(let t=0;t<=s;t++)i[t]=[t];for(let t=0;t<=n;t++)i[0][t]=t;for(let r=1;r<=s;r++){const s=i[r],o=i[r-1];for(let i=1;i<=n;i++)if(e.charAt(r-1)===t.charAt(i-1))s[i]=o[i-1];else{const t=o[i-1]+1,e=s[i-1]+1,n=o[i]+1;s[i]=Math.min(t,e,n)}}return i[s][n]},u=(t,e)=>{const n=new Map;t.forEach((s,i)=>{const r=e(s,i,t);n.set(r,n.has(r)?[...n.get(r),s]:[s])});return n},g=(t,e,n=!1)=>{const s=u(e,e=>a(t,e));return n?s:s.get(Math.min(...s.keys()))},c=t=>{if(r(t))return Array.from(t.entries());if(o(t))return Array.from(Object.entries(t));return null};class h extends Map{constructor(t){super(c(t))}hasIgnoreCase(t){return Array.from(this.keys()).map(t=>t.toLowerCase()).includes(t.toLowerCase())}getIgnoreCase(t){let e=null;return this.forEach((n,s)=>{t.toLowerCase()===s.toLowerCase()&&(e=n)}),e}}var l;!function(t){t[t.ERROR=0]="ERROR",t[t.WARN=1]="WARN",t[t.INFO=2]="INFO",t[t.DEBUG=3]="DEBUG",t[t.TRACE=4]="TRACE"}(l||(l={}));let f=l.TRACE;const p=(t,e)=>`${(new Date).toISOString()} ${e} ${t} -`;class m{constructor(t){this.name=t}error(...t){f>=l.ERROR&&console.error(p(this.name,"ERROR"),...t)}warn(...t){f>=l.WARN&&console.warn(p(this.name,"WARN"),...t)}info(...t){f>=l.INFO&&console.info(p(this.name,"INFO"),...t)}debug(...t){f>=l.DEBUG&&console.log(p(this.name,"DEBUG"),...t)}trace(...t){f>=l.TRACE&&console.log(p(this.name,"TRACE"),...t)}}const d=new Map,A={setLevel:t=>{f=t},getLogger:t=>{let e;if("name"in t)e=t.name;else{if(!i(t))throw new TypeError(`'${t}' is neither an INameable or a string.`);e=t}if(d.has(e))return d.get(e);const n=new m(e);d.set(e,n);return n}};class w{constructor(t,e){this.missing=[],this.result=new Map;const n=A.getLogger(w);n.debug(`Matching arguments ${t} with ${e}`),t.forEach((t,s)=>{if(s<e.length){const i=e[s];n.trace(`Found matching argument for ${t.name}, adding to result: ${i}`),this.result.set(t.name,i)}else t.required||null==t.defaultValue?(n.trace(`No matching argument found for ${t.name}, adding to missing.`),this.missing.push(t)):(n.trace(`No matching argument found for ${t.name}, using default: ${t.defaultValue}`),this.result.set(t.name,t.defaultValue))}),n.debug(`Finished matching arguments: ${t.length} expected, ${this.result.size} found and ${this.missing.length} missing.`)}}const R=(t,e)=>g(e,Array.from(t.keys()),!1);class E{constructor(t=!0){this.logger=A.getLogger(E),this.caseSensitive=t}resolve(t,e,n=!1){return this.resolveInternal(t,e,[],n)}resolveInternal(t,e,n,i=!1){if(0===e.length)throw new Error("Path cannot be empty.");const r=e[0],o=e.slice(1);if(n.push(r),this.caseSensitive?!t.has(r):!t.hasIgnoreCase(r))return this.logger.warn(`Command '${r}' could not be found.`),{successful:!1,pathUsed:n,pathDangling:o,type:1,missing:r,similar:R(t,r)};const a=this.caseSensitive?t.get(r):t.getIgnoreCase(r);this.logger.debug(`Successfully looked up command: ${r}`);let u;if(!i||s(a.args)||0===a.args.length)this.logger.debug("No arguments defined, using empty list."),u=new Map;else{this.logger.debug(`Looking up arguments: ${o}`);const t=new w(a.args,o);if(t.missing.length>0)return this.logger.warn(`Some arguments could not be found: ${t.missing}`),{successful:!1,pathUsed:n,pathDangling:o,type:2,missing:t.missing};u=t.result,this.logger.debug(`Successfully looked up arguments: ${u}`)}const g={successful:!0,pathUsed:n,pathDangling:o,type:0,command:a,args:u};return this.logger.debug(`Returning successful lookup result: ${g}`),g}}class y{constructor(t=['"']){this.logger=A.getLogger(y),this.legalQuotes=t,this.pattern=this.generateMatcher()}parse(t){return this.logger.debug(`Parsing input '${t}'`),Array.from(t.match(this.pattern))}generateMatcher(){this.logger.debug("Creating matcher.");const t=this.legalQuotes.map(t=>`\\Q${t}\\E`).map(t=>`${t}(.+?)${t}`);t.push("(\\S+)");let e;try{e=new RegExp(t.join("|"),"")}catch(t){throw this.logger.error("The parsing pattern is invalid, this should never happen.",t),t}return e}}class b{constructor(t=new Map,e=!0,n=['"']){this.logger=A.getLogger(b),this.lookupResolver=new E(e),this.inputParser=new y(n),this.map=new h(t),this.mapAliased=new h,this.updateAliases()}setCommand(t,e){this.map.set(t,e),this.updateAliases()}getCommand(t){return this.mapAliased.get(t)}hasCommand(t){return this.mapAliased.has(t)}hasPath(t){const e=this.getPath(t);return null!=e&&e.successful}getPath(t){return this.logger.debug(`Resolving pathUsed: ${t}`),this.lookupResolver.resolve(this.mapAliased,t)}parse(t){return this.logger.debug(`Parsing input: '${t}'`),this.lookupResolver.resolve(this.mapAliased,this.inputParser.parse(t),!0)}updateAliases(){this.logger.debug("Updating aliased map."),this.mapAliased.clear(),this.map.forEach((t,e)=>{this.mapAliased.set(e,t);t.alias.forEach(n=>{this.mapAliased.has(n)?this.logger.warn(`Alias '${n}' conflicts with a previously defined key, will be ignored.`):(this.logger.trace(`Created alias '${n}' for '${e}'`),this.mapAliased.set(n,t))})}),this.logger.debug("Done updating aliased map.")}}return t.Clingy=b,t}({});
//# sourceMappingURL=clingy.min.js.map
