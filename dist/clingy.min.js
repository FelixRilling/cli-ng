var clingy=function(e){"use strict";const t=(e,...t)=>t.some(t=>e instanceof t),n=(e,...t)=>t.some(t=>typeof e===t),s=e=>null==e,i=e=>!s(e)&&n(e,"object"),o=(e,t)=>{for(const[n,s]of Object.entries(e))t(s,n,e)},r=e=>n(e,"function"),u=e=>t(e,Map),a=e=>i(e)||r(e),l=e=>a(e)&&e.constructor===Object,c=(e,t)=>{if(0===e.length)return t.length;if(0===t.length)return e.length;const n=[];for(let e=0;e<=t.length;e++)n[e]=[e];for(let t=0;t<=e.length;t++)n[0][t]=t;for(let s=1;s<=t.length;s++){const i=n[s],o=n[s-1];for(let n=1;n<=e.length;n++)if(t.charAt(s-1)===e.charAt(n-1))i[n]=o[n-1];else{const e=o[n-1]+1,t=i[n-1]+1,s=o[n]+1;i[n]=Math.min(e,t,s)}}return n[t.length][e.length]},g=e=>e.filter(e=>e),h=(e,t)=>{const n=new Map;e.forEach((i,o)=>{const r=t(i,o,e);s(r)||n.set(r,n.has(r)?[...n.get(r),i]:[i])});return n},f=(e,t,n=!1)=>{const s=h(t,t=>c(e,t));if(!n)return s.get(Math.min(...s.keys()));return s};class p extends Map{constructor(e){super(p.getConstructorMap(e))}static createWithOptions(e,t){return u(e)?e.forEach(e=>p.createWithOptionsHelper(e,t)):l(e)&&o(e,e=>p.createWithOptionsHelper(e,t)),new p(e)}static createWithOptionsHelper(e,t){(l(e.sub)||u(e.sub))&&(e.sub=new I(p.createWithOptions(e.sub,t),t))}static getConstructorMap(e){return u(e)?Array.from(e.entries()):a(e)?Array.from(Object.entries(e)):null}hasCommand(e,t){return 1===t?Array.from(this.keys()).map(e=>e.toLowerCase()).includes(e.toLowerCase()):this.has(e)}getCommand(e,t){if(1===t){let t=null;return this.forEach((n,s)=>{e.toLowerCase()===s.toLowerCase()&&(t=n)}),t}return this.has(e)?this.get(e):null}}const m={NONE:{val:-1},ERROR:{name:"ERROR",val:0},WARN:{name:"WARN",val:1},INFO:{name:"INFO",val:2},DEBUG:{name:"DEBUG",val:3},TRACE:{name:"TRACE",val:4}},d=(e,t,n)=>{let s=console.log;e===m.ERROR?s=console.error:e===m.WARN?s=console.warn:e===m.INFO&&(s=console.info);s(`${(new Date).toISOString()} ${e.name} ${t}`,...n)},b=(e,...t)=>t.some(t=>typeof e===t),w=e=>null==e,A=e=>!w(e)&&b(e,"object"),R=e=>b(e,"string"),v=e=>b(e,"function"),y=e=>A(e)||v(e);class E{constructor(e,t){this.root=e,this.name=t}log(e,...t){this.root.getLevel().val>=e.val&&this.root.getAppenders().forEach(n=>n(e,this.name,t))}error(...e){this.log(m.ERROR,...e)}warn(...e){this.log(m.WARN,...e)}info(...e){this.log(m.INFO,...e)}debug(...e){this.log(m.DEBUG,...e)}trace(...e){this.log(m.TRACE,...e)}}class O{constructor(){this.loggers=new Map,this.appenders=new Map([["defaultAppender",d]]),this.level=m.INFO}getLogger(e){let t;if(y(e)&&"name"in e)t=e.name;else{if(!R(e))throw new TypeError(`'${e}' is neither an INameable nor a string.`);t=e}if(this.loggers.has(t))return this.loggers.get(t);const n=new E(this,t);return this.loggers.set(t,n),n}getLevel(){return this.level}setLevel(e){this.level=e}attachAppender(e,t){this.appenders.set(e,t)}detachAppender(e){this.appenders.delete(e)}getAppenders(){return this.appenders}}const C=new O;class M{constructor(e,t){this.missing=[],this.result=new Map,M.logger.debug("Matching arguments:",e,t),e.forEach((e,n)=>{if(n<t.length){const s=t[n];M.logger.trace(`Found matching argument for ${e.name}, adding to result: ${s}`),this.result.set(e.name,s)}else e.required?(M.logger.trace(`No matching argument found for ${e.name}, adding to missing.`),this.missing.push(e)):s(e.defaultValue)?(M.logger.trace(`No matching argument found for ${e.name}, using null.`),this.result.set(e.name,null)):(M.logger.trace(`No matching argument found for ${e.name}, using default: ${e.defaultValue}`),this.result.set(e.name,e.defaultValue))}),M.logger.debug(`Finished matching arguments: ${e.length} expected, ${this.result.size} found and ${this.missing.length} missing.`)}}M.logger=C.getLogger(M);const N=(e,t)=>f(t,Array.from(e.keys()),!1);class S{constructor(e=!0){this.caseSensitivity=e?0:1}static createSuccessResult(e,t,n,s){const i={successful:!0,pathUsed:t,pathDangling:e,type:0,command:n,args:s};return S.logger.debug("Returning successful lookup result:",i),i}static createNotFoundResult(e,t,n,s){return S.logger.warn(`Command '${n}' could not be found.`),{successful:!1,pathUsed:t,pathDangling:e,type:1,missing:n,similar:N(s,n)}}static createMissingArgsResult(e,t,n){return S.logger.warn("Some arguments could not be found:",n),{successful:!1,pathUsed:t,pathDangling:e,type:2,missing:n}}resolve(e,t,n){if(0===t.length)throw new Error("Path cannot be empty.");return this.resolveInternal(e,t,[],n)}resolveInternal(e,n,i,o){const r=n[0],u=n.slice(1);if(i.push(r),!this.hasCommand(e,r))return S.createNotFoundResult(u,i,r,e);const a=e.getCommand(r,this.caseSensitivity);if(S.logger.debug(`Found command: '${r}'.`),u.length>0&&t(a.sub,I)&&this.hasCommand(a.sub.mapAliased,u[0]))return this.resolveInternalSub(u,i,a,o);let l;if(1===o||s(a.args)||0===a.args.length)S.logger.debug("No arguments defined, using empty map."),l=new Map;else{S.logger.debug(`Looking up arguments: '${u}'.`);const e=new M(a.args,u);if(e.missing.length>0)return S.createMissingArgsResult(u,i,e.missing);l=e.result,S.logger.debug("Successfully looked up arguments: ",l)}return S.createSuccessResult(u,i,a,l)}resolveInternalSub(e,t,n,s){return S.logger.debug("Resolving sub-commands:",n.sub,e),this.resolveInternal(n.sub.mapAliased,e,t,s)}hasCommand(e,t){return e.hasCommand(t,this.caseSensitivity)}}S.logger=C.getLogger(S);class L{constructor(e=['"']){this.legalQuotes=e,this.pattern=this.generateMatcher()}parse(e){L.logger.debug(`Parsing input '${e}'`);const t=[],n=new RegExp(this.pattern);let s;for(;s=n.exec(e);){L.logger.trace(`Found match '${s}'`);const e=g(s.slice(1));e.length>0&&(L.logger.trace(`Found group '${e[0]}'`),t.push(e[0]))}return t}generateMatcher(){L.logger.debug("Creating matcher.");const e=this.legalQuotes.map(e=>`\\${e}`).map(e=>`${e}(.+?)${e}`);e.push("(\\S+)");let t;try{t=new RegExp(e.join("|"),"g")}catch(e){throw L.logger.error("The parsing pattern is invalid, this should never happen.",e),e}return t}}L.logger=C.getLogger(L);class I{constructor(e={},t={}){this.lookupResolver=new S(t.caseSensitive),this.inputParser=new L(t.legalQuotes),this.map=p.createWithOptions(e,t),this.mapAliased=new p,this.updateAliases()}setCommand(e,t){this.map.set(e,t),this.updateAliases()}getCommand(e){return this.mapAliased.get(e)}hasCommand(e){return this.mapAliased.has(e)}hasPath(e){return this.getPath(e).successful}getPath(e){return I.logger.debug(`Resolving pathUsed: ${e}`),this.lookupResolver.resolve(this.mapAliased,e,1)}parse(e){return I.logger.debug(`Parsing input: '${e}'`),this.lookupResolver.resolve(this.mapAliased,this.inputParser.parse(e),0)}updateAliases(){I.logger.debug("Updating aliased map."),this.mapAliased.clear(),this.map.forEach((e,t)=>{this.mapAliased.set(t,e);e.alias.forEach(n=>{this.mapAliased.has(n)?I.logger.warn(`Alias '${n}' conflicts with a previously defined key, will be ignored.`):(I.logger.trace(`Created alias '${n}' for '${t}'`),this.mapAliased.set(n,e))})}),I.logger.debug("Done updating aliased map.")}}return I.logger=C.getLogger(I),e.Clingy=I,e.clingyLogby=C,e}({});
//# sourceMappingURL=clingy.min.js.map
