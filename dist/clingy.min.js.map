{"version":3,"file":"clingy.min.js","sources":["../node_modules/loglevel/lib/loglevel.js","../node_modules/lightdash/dist/lightdash.esm.js"],"sourcesContent":["/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n","/**\n * Checks if the value has a certain type-string.\n *\n * @function isTypeOf\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @param {string} type\n * @returns {boolean}\n * @example\n * isTypeOf({}, \"object\")\n * // => true\n *\n * isTypeOf([], \"object\")\n * // => true\n *\n * isTypeOf(\"foo\", \"string\")\n * // => true\n *\n * @example\n * isTypeOf(\"foo\", \"number\")\n * // => false\n */\nconst isTypeOf = (val, type) => typeof val === type;\n\n/**\n * Checks if a value is a function.\n *\n * @function isFunction\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isFunction(function a(){})\n * // => true\n *\n * isFunction(Array.from)\n * // => true\n *\n * @example\n * isFunction(null)\n * // => false\n */\nconst isFunction = (val) => isTypeOf(val, \"function\");\n\n/**\n * Checks if a value is an arguments array-like.\n *\n * @function isArguments\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * const foo = function(){\n *   return arguments;\n * };\n *\n * isArguments(foo());\n * // => true\n *\n * @example\n * isArguments([]);\n * // => false\n */\nconst isArguments = (val) => isFunction(val.callee);\n\n/**\n * Checks if a value is an array.\n *\n * `Array.isArray` shorthand.\n *\n * @function isArray\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isArray([]);\n * // => true\n *\n * isArray([1, 2, 3]);\n * // => true\n *\n * @example\n * isArray({});\n * // => false\n */\nconst isArray = Array.isArray;\n\n/**\n * Checks if the value is an instance of a target constructor.\n *\n * @function isInstanceOf\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @param {Class} target\n * @returns {boolean}\n * @example\n * isInstanceOf({}, Object)\n * // => true\n *\n * isInstanceOf([], Object)\n * // => true\n *\n * isInstanceOf([], Array)\n * // => true\n *\n * @example\n * isInstanceOf({}, Array)\n * // => false\n *\n * isInstanceOf([], Map)\n * // => false\n */\nconst isInstanceOf = (val, target) => val instanceof target;\n\n/**\n * Checks if a value is an array-buffer.\n *\n * @function isArrayBuffer\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isArrayBuffer(new ArrayBuffer())\n * // => true\n *\n * @example\n * isArrayBuffer([1, 2])\n * // => false\n */\n// @ts-ignore: ArrayBuffer declaration is invalid\nconst isArrayBuffer = (val) => isInstanceOf(val, ArrayBuffer);\n\n/**\n * Checks if a value is undefined.\n *\n * @function isUndefined\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * const a = {};\n *\n * isUndefined(a.b)\n * // => true\n *\n * isUndefined(undefined)\n * // => true\n *\n * @example\n * const a = {};\n *\n * isUndefined(1)\n * // => false\n *\n * isUndefined(a)\n * // => false\n */\nconst isUndefined = (val) => isTypeOf(val, \"undefined\");\n\n/**\n * Checks if a value is undefined or null.\n *\n * @function isNil\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isNil(null)\n * // => true\n *\n * isNil(undefined)\n * // => true\n *\n * @example\n * isNil(0)\n * // => false\n *\n * isNil(\"\")\n * // => false\n */\nconst isNil = (val) => val == null;\n\n/**\n * Checks if a value is not nil and has a type of object.\n *\n * The main difference to isObject is that functions are not considered object-like,\n * because `typeof function(){}` returns \"function\".\n *\n * @function isObjectLike\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isObjectLike({})\n * // => true\n *\n * isObjectLike([])\n * // => true\n *\n * @example\n * isObjectLike(1)\n * // => false\n *\n * isObjectLike(() => 1))\n * // => false\n */\nconst isObjectLike = (val) => !isNil(val) && isTypeOf(val, \"object\");\n\n/**\n * Checks if a value is object-like and has a length property.\n *\n * @function isArrayLike\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isArrayLike([])\n * // => true\n *\n * isArrayLike({length: 0})\n * // => true\n *\n * @example\n * isArrayLike({})\n * // => false\n *\n * isArrayLike(\"foo\")\n * // => false\n */\nconst isArrayLike = (val) => isObjectLike(val) && !isUndefined(val.length);\n\n/**\n * Checks if a value is a number.\n *\n * @function isNumber\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isNumber(1)\n * // => true\n *\n * isNumber(2.34)\n * // => true\n *\n * isNumber(Infinity)\n * // => true\n *\n * isNumber(NaN)\n * // => true\n * // (NaN is considered a number, see IEEE_754)\n *\n * @example\n * isNumber(\"2\")\n * // => false\n *\n * isNumber(null)\n * // => false\n */\nconst isNumber = (val) => isTypeOf(val, \"number\");\n\n/**\n * Checks if a value is a typed array.\n *\n * @function isArrayTyped\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isArrayTyped(new Int16Array());\n * // => true\n *\n * isArrayTyped(new Uint8Array());\n * // => true\n *\n * @example\n * isArrayTyped([]);\n * // => false\n */\nconst isArrayTyped = (val) => isNumber(val.BYTES_PER_ELEMENT);\n\n/**\n * Checks if a value is a boolean.\n *\n * @function isBoolean\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isBoolean(true)\n * // => true\n *\n * isBoolean(false)\n * // => true\n *\n * @example\n * isBoolean(0)\n * // => false\n *\n * isBoolean(null)\n * // => false\n *\n * isBoolean(\"\")\n * // => false\n */\nconst isBoolean = (val) => isTypeOf(val, \"boolean\");\n\n/**\n * Checks if a value is a date object.\n *\n * @function isDate\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isDate(Date())\n * // => true\n *\n * isDate(new Date())\n * // => true\n *\n * @example\n * isDate(123213231)\n * // => false\n */\nconst isDate = (val) => isInstanceOf(val, Date);\n\n/**\n * Checks if a value is a string.\n *\n * @function isString\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isString(\"foo\")\n * // => true\n *\n * @example\n * isString(1)\n * // => false\n */\nconst isString = (val) => isTypeOf(val, \"string\");\n\n/**\n * Gets size of a value.\n *\n * If the value has a length or size property, the value of that is returned.\n * If the value is object-like, the length of its entries is returned.\n * Otherwise -1 is returned.\n *\n * @function getSize\n * @memberof Get\n * @since 6.0.0\n * @param {any} val\n * @returns {number}\n * @example\n * getSize([1,2])\n * // => 2\n *\n * getSize({a:1})\n * // => 1\n *\n * getSize(new Set())\n * // => 0\n *\n * isEmpty(\"foo\")\n * // => 3\n *\n * isEmpty(1)\n * // => -1\n *\n * isEmpty(null)\n * // => -1\n */\nconst getSize = (val) => {\n    if (isNil(val)) {\n        return -1;\n    }\n    else if (isArrayLike(val) || isString(val)) {\n        return val.length;\n    }\n    else if (!isUndefined(val.size)) {\n        return val.size;\n    }\n    else if (isObjectLike(val)) {\n        return Object.keys(val).length;\n    }\n    return -1;\n};\n\n/**\n * Checks if a value is empty.\n *\n * A value is consider empty if it is either a primitive or an object-like without content.\n * Array-likes and strings are considered empty if they have a length of zero,\n * Sets/Maps if they have a size of zero,\n * and Objects if their keys have a length of zero.\n *\n * @function isEmpty\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isEmpty([])\n * // => true\n *\n * isEmpty({})\n * // => true\n *\n * isEmpty(\"\")\n * // => true\n *\n * isEmpty(true)\n * // => true\n *\n * isEmpty(1)\n * // => true\n *\n * isEmpty(null)\n * // => true\n *\n * @example\n * isEmpty(\"foo\")\n * // => false\n *\n * isEmpty([1, 2])\n * // => false\n *\n * isEmpty({a: 1})\n * // => false\n */\nconst isEmpty = (val) => getSize(val) < 1;\n\n/**\n * Iterates over each entry of an object.\n *\n * @function forEachEntry\n * @memberof For\n * @param {object} obj\n * @param {function} fn fn(key: any, val: any, index: number, arr: any[])\n * @example\n * const a = {a: 1, b: 2};\n *\n * forEachEntry(a, (key, val, index) => a[key] = val * index)\n * // a = {a: 0, b: 2}\n */\nconst forEachEntry = (obj, fn) => {\n    Object.entries(obj).forEach((entry, index) => {\n        fn(entry[0], entry[1], index, obj);\n    });\n};\n\n/**\n * Recursively checks if two items and their the contents are equal.\n *\n * @function isEqual\n * @memberof Is\n * @since 1.0.0\n * @param {any} a\n * @param {any} b\n * @returns {boolean}\n * @example\n * isEqual(1, 1)\n * // => true\n *\n * isEqual({}, {})\n * // => true\n *\n * isEqual([1, 2], [1, 2])\n * // => true\n *\n * isEqual([1, 2, [3, 4]], [1, 2, [3, 4]])\n * // => true\n *\n * @example\n * isEqual([1, 2, 3], [1])\n * // => false\n *\n * isEqual(1, true)\n * // => false\n */\nconst isEqual = (a, b) => {\n    if (a === b) {\n        return true;\n    }\n    if (!isObjectLike(a) ||\n        !isObjectLike(b) ||\n        Object.keys(a).length !== Object.keys(b).length) {\n        return false;\n    }\n    let result = true;\n    forEachEntry(a, (key, aVal) => {\n        // Only check if the comparison didn't fail already\n        if (result === true) {\n            if (!isUndefined(b[key])) {\n                result = isEqual(aVal, b[key]);\n            }\n            else {\n                result = false;\n            }\n        }\n    });\n    return result;\n};\n\n/**\n * Checks if a value is an error.\n *\n * @function isError\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isError(new Error())\n * // => true\n *\n * isError(new URIError())\n * // => true\n *\n * @example\n * isError(\"foo\")\n * // => false\n */\nconst isError = (val) => isInstanceOf(val, Error);\n\n/**\n * Checks if a value is a valid index.\n *\n * @function isIndex\n * @memberof Is\n * @since 5.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isIndex(0)\n * // => true\n *\n * isIndex(123)\n * // => true\n *\n * @example\n * isIndex(0.43)\n * // => false\n *\n * isIndex(-4)\n * // => false\n *\n * isIndex(Infinity)\n * // => false\n */\nconst isIndex = (val) => Number.isInteger(val) && val >= 0;\n\n/**\n * Checks if a value is a map.\n *\n * @function isMap\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isMap(new Map())\n * // => true\n *\n * @example\n * isMap([[1, 2]])\n * // => false\n */\nconst isMap = (val) => isInstanceOf(val, Map);\n\n/**\n * Checks if a value is null.\n *\n * @function isNull\n * @memberof Is\n * @since 7.1.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isNull(null)\n * // => true\n *\n * @example\n * isNull(0)\n * // => false\n *\n * isNull(undefined)\n * // => false\n */\nconst isNull = (val) => val === null;\n\n/**\n * Checks if a value is an object.\n *\n * @function isObject\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isObject({})\n * // => true\n *\n * isObject([])\n * // => true\n *\n * isObject(() => 1))\n * // => true\n *\n * @example\n * isObject(1)\n * // => false\n */\nconst isObject = (val) => !isNil(val) && (isTypeOf(val, \"object\") || isTypeOf(val, \"function\"));\n\n/**\n * Checks if a value is a plain object.\n *\n * An object is considered plain of its direct constructor is the built-in object constructor.\n *\n * @function isObjectPlain\n * @memberof Is\n * @since 2.9.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isObjectPlain({})\n * // => true\n *\n * @example\n * isObjectPlain([])\n * // => false\n *\n * isObjectPlain(() => {})\n * // => false\n */\nconst isObjectPlain = (val) => isObject(val) && val.constructor === Object;\n\n/**\n * Checks if a value is a promise.\n *\n * @function isPromise\n * @memberof Is\n * @since 3.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * const foo = new Promise((resolve, reject) => resolve(\"foo\"));\n *\n * isPromise(foo);\n * // => true\n *\n * @example\n * isPromise(() => \"foo\");\n * // => false\n */\nconst isPromise = (val) => isFunction(val.then) && isFunction(val.catch);\n\n/**\n * Checks if a value is a regular expression.\n *\n * @function isRegExp\n * @memberof Is\n * @since 2.10.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isRegExp(new RegExp(\"foo\"))\n * // => true\n *\n * isRegExp(/foo/)\n * // => true\n *\n * @example\n * isRegExp(\"foo\")\n * // => false\n */\n// @ts-ignore: RegExp declaration is invalid\nconst isRegExp = (val) => isInstanceOf(val, RegExp);\n\n/**\n * Checks if a value is a set.\n *\n * @function isSet\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isSet(new Set())\n * // => true\n *\n * @example\n * isSet([1, 2])\n * // => false\n */\nconst isSet = (val) => isInstanceOf(val, Set);\n\n/**\n * Checks if a value is a symbol.\n *\n * @function isSymbol\n * @memberof Is\n * @since 1.0.0\n * @param {any} val\n * @returns {boolean}\n * @example\n * isSymbol(Symbol())\n * // => true\n *\n * isSymbol(Symbol.split)\n * // => true\n *\n * @example\n * isSymbol(\"foo\")\n * // => false\n */\nconst isSymbol = (val) => isTypeOf(val, \"symbol\");\n\n/**\n * Returns a targets value in a given path.\n *\n * If the path doesn't exist in the target, null is returned.\n *\n * @function getPath\n * @memberof Get\n * @since 2.0.0\n * @param {any} target\n * @param {string[]} path\n * @returns {null|any}\n * @example\n * getPath({a: 1}, [\"a\"]);\n * // => 1\n *\n * getPath([4, 6, 8], [\"1\"]);\n * // => 6\n *\n * getPath({a: {b: 2, c: [10, 20]}}, [\"a\", \"c\", \"0\"]);\n * // => 10\n */\nconst getPath = (target, path) => {\n    let targetCurrent = target;\n    let index = 0;\n    while (!isUndefined(targetCurrent) && index < path.length) {\n        const keyCurrent = path[index];\n        if (isUndefined(targetCurrent[keyCurrent])) {\n            return null;\n        }\n        targetCurrent = targetCurrent[keyCurrent];\n        index++;\n    }\n    return targetCurrent;\n};\n\n/**\n * Checks if a target has a given path.\n *\n * @function hasPath\n * @memberof Has\n * @since 2.0.0\n * @param {any} target\n * @param {string[]} path\n * @returns {boolean}\n * @example\n * hasPath({a: 1}, [\"a\"]);\n * // => true\n *\n * hasPath([4, 6, 8], [\"1\"]);\n * // => true\n *\n * hasPath({a: {b: 2, c: [10, 20]}}, [\"a\", \"c\", \"0\"]);\n * // => true\n *\n * @example\n * hasPath({a: 1}, [\"c\"]);\n * // => false\n *\n * hasPath([4, 6, 8], [\"8\"]);\n * // => false\n *\n * hasPath({a: {b: 2, c: [10, 20]}}, [\"f\", \"x\", \"231\", \"21\"]);\n * // => false\n *\n * hasPath(1, [\"foo\"]);\n * // => false\n */\nconst hasPath = (target, path) => !isNil(getPath(target, path));\n\n/**\n * Returns the sum of an array of numbers.\n *\n * @function numSum\n * @memberof Number\n * @since 5.0.0\n * @param {number[]} arr\n * @returns {number}\n * @example\n * numSum([1, 2.5, 3.3])\n * // => 6.8\n */\nconst numSum = (arr) => arr.reduce((a, b) => a + b);\n\n/**\n * Returns the average of an array of numbers.\n *\n * @function numAverage\n * @memberof Number\n * @since 5.0.0\n * @param {number[]} arr\n * @returns {number}\n * @example\n * numAverage([1, 2.5, 3.3])\n * // => 2.2666\n */\nconst numAverage = (arr) => numSum(arr) / arr.length;\n\n/**\n * Clamps a number in a given range.\n *\n * @function numClamp\n * @memberof Number\n * @since 1.0.0\n * @param {number} val\n * @param {number} min\n * @param {number} max\n * @returns {number}\n * @example\n * numClamp(5, 0, 10)\n * // => 5\n *\n * numClamp(-2, 0, 10)\n * // => 0\n *\n * numClamp(99, 0, 10)\n * // => 10\n */\nconst numClamp = (val, min, max) => {\n    if (val < min) {\n        return min;\n    }\n    else if (val > max) {\n        return max;\n    }\n    return val;\n};\n\n/**\n * Returns the median of an array of numbers.\n *\n * @function numMedian\n * @memberof Number\n * @since 5.0.0\n * @param {number[]} arr\n * @returns {number}\n * @example\n * numMedian([1, 2.5, 3.3])\n * // => 2.5\n *\n * numMedian([1, 2, 4, 5])\n * // => 3\n */\nconst numMedian = (arr) => {\n    const arrLengthHalf = arr.length / 2;\n    return arr.length % 2 === 0\n        ? arr[arrLengthHalf]\n        : numAverage(arr.slice(Math.floor(arrLengthHalf), 2));\n};\n\n/**\n * Clamps a number in the range of safe integers.\n *\n * @function numSafe\n * @memberof Number\n * @since 7.1.0\n * @param {number} val\n * @returns {number}\n * @example\n * numSafe(5)\n * // => 5\n *\n * numSafe(Number.MAX_VALUE)\n * // => Number.MIN_SAFE_INTEGER\n *\n * numSafe(Infinity)\n * // => Number.MIN_SAFE_INTEGER\n */\nconst numSafe = (val) => numClamp(val, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n\n/**\n * Returns levenshtein string distance of two strings.\n *\n * @function strDistance\n * @memberof String\n * @since 6.3.0\n * @param {string} str1\n * @param {string} str2\n * @returns {number}\n * @example\n * strDistance(\"Kitten\", \"Sitting\")\n * // => 3\n *\n * strDistance(\"String\", \"Stribng\")\n * // => 1\n *\n * strDistance(\"foo\", \"foo\")\n * // => 0\n */\nconst strDistance = (str1, str2) => {\n    // Cache string length\n    const str1Length = str1.length;\n    const str2Length = str2.length;\n    if (str1Length === 0) {\n        // Exit early if str1 is empty\n        return str2Length;\n    }\n    if (str2Length === 0) {\n        // Exit early if str2 is empty\n        return str1Length;\n    }\n    // Create matrix that is (str2.length+1)x(str1.length+1) fields\n    const matrix = [];\n    // Increment along the first column of each row\n    for (let y = 0; y <= str2Length; y++) {\n        matrix[y] = [y];\n    }\n    // Increment each column in the first row\n    for (let x = 0; x <= str1Length; x++) {\n        matrix[0][x] = x;\n    }\n    // Fill matrix\n    for (let y = 1; y <= str2Length; y++) {\n        const matrixColumnCurrent = matrix[y];\n        const matrixColumnLast = matrix[y - 1];\n        for (let x = 1; x <= str1Length; x++) {\n            if (str2.charAt(y - 1) === str1.charAt(x - 1)) {\n                // Check if letter at the position is the same\n                matrixColumnCurrent[x] = matrixColumnLast[x - 1];\n            }\n            else {\n                // Check for substitution/insertion/deletion\n                const substitution = matrixColumnLast[x - 1] + 1;\n                const insertion = matrixColumnCurrent[x - 1] + 1;\n                const deletion = matrixColumnLast[x] + 1;\n                // Get smallest of the three\n                matrixColumnCurrent[x] = Math.min(substitution, insertion, deletion);\n            }\n        }\n    }\n    // Return max value\n    return matrix[str2Length][str1Length];\n};\n\n/**\n * Returns an array with every falsey value removed out.\n *\n * @function arrCompact\n * @memberof Array\n * @since 1.0.0\n * @param {any[]} arr\n * @returns {any[]}\n * @example\n * arrCompact([1, \"\", \"\", 2, 3, null, 4, undefined, 5, \"\"])\n * // => [1, 2, 3, 4, 5]\n */\nconst arrCompact = (arr) => arr.filter((val) => val);\n\n/**\n * Creates an array of substrings from a PascalCase string.\n *\n * @function strFromPascalCase\n * @memberof String\n * @since 6.2.0\n * @param {string} str\n * @returns {string[]}\n * @example\n * strFromPascalCase(\"FooBar\")\n * // => [\"Foo\", \"Bar\"]\n *\n * strFromPascalCase(\"FizzBuzzBazz\")\n * // => [\"Fizz\",\"Buzz\",\"Bazz\"]\n */\nconst strFromPascalCase = (str) => {\n    const result = [];\n    let cache = [];\n    str.split(\"\").forEach((letter, index) => {\n        if (index > 0 && letter !== letter.toLowerCase()) {\n            result.push(cache.join(\"\"));\n            cache = [];\n        }\n        cache.push(letter);\n    });\n    result.push(cache.join(\"\"));\n    return arrCompact(result);\n};\n\n/**\n * Creates an array of substrings from a camelCase string.\n *\n * @function strFromCamelCase\n * @memberof String\n * @since 6.2.0\n * @param {string} str\n * @returns {string[]}\n * @example\n * strFromPascalCase(\"fooBar\")\n * // => [\"foo\", \"Bar\"]\n *\n * strFromPascalCase(\"fizzBuzzBazz\")\n * // => [\"fizz\",\"Buzz\",\"Bazz\"]\n */\nconst strFromCamelCase = strFromPascalCase;\n\n/**\n * Creates an array of substrings from a kebab-case string.\n *\n * @function strFromKebabCase\n * @memberof String\n * @since 6.2.0\n * @param {string} str\n * @returns {string[]}\n * @example\n * strFromKebabCase(\"foo-bar\")\n * // => [\"foo\", \"bar\"]\n *\n * strFromKebabCase(\"Fizz-buzz-BaZZ\")\n * // => [\"Fizz\",\"buzz\",\"BaZZ\"]\n */\nconst strFromKebabCase = (str) => arrCompact(str.split(\"-\" /* kebab */));\n\n/**\n * Creates an array of substrings from a snake_case string.\n *\n * @function strFromSnakeCase\n * @memberof String\n * @since 6.2.0\n * @param {string} str\n * @returns {string[]}\n * @example\n * strFromSnakeCase(\"foo_bar\")\n * // => [\"foo\", \"bar\"]\n *\n * strFromSnakeCase(\"Fizz_buzz_BaZZ\")\n * // => [\"Fizz\",\"buzz\",\"BaZZ\"]\n */\nconst strFromSnakeCase = (str) => arrCompact(str.split(\"_\" /* snake */));\n\n/**\n * Collects the values of an array in a Map as arrays.\n *\n * @function arrCollect\n * @memberof Array\n * @since 6.1.0\n * @param {any[]} arr\n * @param {function} fn fn(val: any, index: number, arr: any[])\n * @returns {Map<any, any[]>} Map<val: any, arr: any[]>\n * @example\n * arrCollect([1, 2, 3, 4, 5], val => val % 2)\n * // => Map<any, any[]>{0: [2, 4], 1: [1, 3, 5]}\n */\nconst arrCollect = (arr, fn) => {\n    const result = new Map();\n    arr.forEach((val, index) => {\n        const key = fn(val, index, arr);\n        result.set(key, result.has(key) ? [...result.get(key), val] : [val]);\n    });\n    return result;\n};\n\n/**\n * Returns strings similar to the input based on the list given.\n *\n * @function strSimilar\n * @memberof String\n * @since 6.3.0\n * @param {string} str\n * @param {Array<string>} list\n * @param {boolean} [returnFull=false]\n * @returns {Array<string>|Map<number,string[]>}\n * @example\n * strSimilar(\"Fob\", [\"Foo\", \"Bar\"])\n * // => [\"Foo\"]\n *\n * strSimilar(\"cmmit\", [\"init\", \"commit\", \"push\"])\n * // => [\"commit\"]\n *\n * strSimilar(\"Kitten\", [\"Sitten\", \"Sitting\", \"Bitten\"])\n * // => [\"Sitten\", \"Bitten\"]\n *\n * strSimilar(\"cmmit\", [\"init\", \"commit\", \"push\"], true)\n * // => Map<number, string[]>{\"1\": [\"commit\"], \"3\": [\"init\"], \"5\": [\"push\"]}\n */\nconst strSimilar = (str, list, returnFull = false) => {\n    const result = arrCollect(list, val => strDistance(str, val));\n    return returnFull\n        ? result\n        : result.get(Math.min(...result.keys()));\n};\n\n/**\n * Creates a camelCase string from an array of substrings.\n *\n * @function strToCamelCase\n * @memberof String\n * @since 6.2.0\n * @param {string[]} arr\n * @returns {string}\n * @example\n * strToCamelCase([\"foo\", \"bar\"])\n * // => \"fooBar\"\n *\n * strToCamelCase([\"Fizz\",\"buzz\",\"BaZZ\"])\n * // => \"fizzBuzzBazz\"\n */\nconst strToCamelCase = (arr) => arr\n    .map((val, index) => index === 0\n    ? val.toLowerCase()\n    : val.substr(0, 1).toUpperCase() +\n        val.substr(1).toLowerCase())\n    .join(\"\");\n\n/**\n * Creates a kebab-case string from an array of substrings.\n *\n * @function strToKebabCase\n * @memberof String\n * @since 6.2.0\n * @param {string[]} arr\n * @returns {string}\n * @example\n * strToKebabCase([\"foo\", \"bar\"])\n * // => \"foo-bar\"\n *\n * strToKebabCase([\"Fizz\",\"buzz\",\"BaZZ\"])\n * // => \"fizz-buzz-bazz\"\n */\nconst strToKebabCase = (arr) => arr.map(val => val.toLowerCase()).join(\"-\" /* kebab */);\n\n/**\n * Creates a PascalCase string from an array of substrings.\n *\n * @function strToPascalCase\n * @memberof String\n * @since 6.2.0\n * @param {string[]} arr\n * @returns {string}\n * @example\n * strToPascalCase([\"foo\", \"bar\"])\n * // => \"FooBar\"\n *\n * strToPascalCase([\"Fizz\",\"buzz\",\"BaZZ\"])\n * // => \"FizzBuzzBazz\"\n */\nconst strToPascalCase = (arr) => arr\n    .map(val => val.substr(0, 1).toUpperCase() + val.substr(1).toLowerCase())\n    .join(\"\");\n\n/**\n * Creates a snake_case string from an array of substrings.\n *\n * @function strToSnakeCase\n * @memberof String\n * @since 6.2.0\n * @param {string[]} arr\n * @returns {string}\n * @example\n * strToSnakeCase([\"foo\", \"bar\"])\n * // => \"foo_bar\"\n *\n * strToSnakeCase([\"Fizz\",\"buzz\",\"BaZZ\"])\n * // => \"fizz_buzz_bazz\"\n */\nconst strToSnakeCase = (arr) => arr.map(val => val.toLowerCase()).join(\"_\" /* snake */);\n\n/**\n * Creates an array of elements split into groups by size.\n *\n * @function arrChunk\n * @memberof Array\n * @since 2.0.0\n * @param {any[]} arr\n * @param {number} chunk\n * @returns {any[]}\n * @example\n * arrChunk([1, 2, 3, 4, 5, 6], 2)\n * // => [[1, 2], [3, 4], [5, 6]]\n *\n * arrChunk([1, 2, 3, 4, 5], 3)\n * // => [[1, 2, 3], [4, 5]]\n */\nconst arrChunk = (arr, chunk) => {\n    if (!isIndex(chunk) || chunk === 0) {\n        return [];\n    }\n    const result = [];\n    for (let i = 0; i < arr.length; i += chunk) {\n        result.push(arr.slice(i, i + chunk));\n    }\n    return result;\n};\n\n/**\n * Counts how many times an element appears in an array.\n *\n * @function arrCount\n * @memberof Array\n * @since 2.0.0\n * @param {any[]} arr\n * @returns {Map<any, number>} Map<val: any, count: number>\n * @example\n * arrCount([1, 1, 2, 2, 1, 3, 4, 1])\n * // => Map<any, number>{1: 4, 2: 2, 3: 1, 4: 1}\n */\nconst arrCount = (arr) => {\n    const result = new Map();\n    arr.forEach(val => result.set(val, result.has(val) ? result.get(val) + 1 : 1));\n    return result;\n};\n\n/**\n * Returns an array of all elements that exist in the first array, but not any others.\n *\n * @function arrDifference\n * @memberof Array\n * @since 2.0.0\n * @param {any[]} arr\n * @param {...any[]} values\n * @returns {any[]}\n * @example\n * arrDifference([1, 2, 3], [1, \"foo\", 3])\n * // => [2]\n *\n * arrDifference([1, 2, 3], [\"foo\"], [2, 0, 2])\n * // => [1, 3]\n */\nconst arrDifference = (arr, ...values) => {\n    const valuesCounted = arrCount([].concat(...values));\n    return arr.filter(item => !valuesCounted.has(item));\n};\n\n/**\n * Recursively maps the values of the input array with the iterator function and return the result.\n *\n * @function arrMapDeep\n * @memberof Array\n * @since 1.0.0\n * @param {any[]} arr\n * @param {function} fn fn(val: any, index: number, arr: any[])\n * @returns {any[]}\n * @example\n * arrMapDeep([2, 4, [1, 1, [16], 4]], val => val * 2)\n * // => [4, 8, [2, 2, [32], 8]]\n */\nconst arrMapDeep = (arr, fn) => arr.map((val, index) => isArray(val) ? arrMapDeep(val, fn) : fn(val, index, arr));\n\n/**\n * Recursively creates a new array with the values of the input iterable.\n *\n * @function arrFromDeep\n * @memberof Array\n * @since 2.0.0\n * @param {any[]} arr\n * @returns {any[]}\n * @example\n * const a = [1, 2, 3, [5, [6]]];\n * const b = arrFromDeep(a);\n *\n * b[3][1][0] = 10;\n * // a = [1, 2, 3, [5, [6]]]\n * // b = [1, 2, 3, [5, [10]]]\n */\nconst arrFromDeep = (arr) => arrMapDeep(Array.from(arr), val => (isArray(val) ? Array.from(val) : val));\n\n/**\n * Returns an array of all elements that exist in the first array and at least once in one of the other arrays.\n *\n * @function arrIntersection\n * @memberof Array\n * @since 2.0.0\n * @param {any[]} arr\n * @param {...any[]} values\n * @returns {any[]}\n * @example\n * arrIntersection([1, 2, 3], [1, \"foo\", 3])\n * // => [1, 3]\n *\n * arrIntersection([1, 2, 3], [\"foo\"], [2, 0, 2])\n * // => [2]\n */\nconst arrIntersection = (arr, ...values) => {\n    const valuesCounted = arrCount([].concat(...values));\n    return arr.filter(item => valuesCounted.has(item));\n};\n\n/**\n * Returns an array with the item at the index removed.\n *\n * @function arrRemoveIndex\n * @memberof Array\n * @since 2.8.0\n * @param {any[]} arr\n * @param {number} targetIndex\n * @returns {any[]}\n * @example\n * arrRemoveIndex([\"foo\", \"bar\", \"fizz\"], 1)\n * // => [\"foo\", \"fizz\"]\n */\nconst arrRemoveIndex = (arr, targetIndex) => arr.filter((val, index) => index !== targetIndex);\n\n/**\n * Returns an array with the first instance of the given item removed.\n *\n * @function arrRemoveFirstItem\n * @memberof Array\n * @since 8.1.0\n * @param {any[]} arr\n * @param {any} targetItem\n * @returns {any[]}\n * @example\n * arrRemoveFirstItem([\"foo\", \"bar\", \"fizz\", \"bar\"], \"bar\")\n * // => [\"foo\", \"fizz\"]\n */\nconst arrRemoveFirstItem = (arr, targetItem) => arrRemoveIndex(arr, arr.indexOf(targetItem));\n\n/**\n * Returns an array with all instances of the given item removed.\n *\n * @function arrRemoveItem\n * @memberof Array\n * @since 2.8.0\n * @param {any[]} arr\n * @param {any} targetItem\n * @returns {any[]}\n * @example\n * arrRemoveItem([\"foo\", \"bar\", \"fizz\", \"bar\"], \"bar\")\n * // => [\"foo\", \"fizz\"]\n */\nconst arrRemoveItem = (arr, targetItem) => arr.filter(item => item !== targetItem);\n\n/**\n * Returns an array with every n-th item from the input array.\n *\n * @function arrStep\n * @memberof Array\n * @since 1.0.0\n * @param {any[]} arr\n * @param {number} step\n * @returns {any[]}\n * @example\n * arrStep([1, 2, 3, 4, 5, 6], 2)\n * // => [1, 3, 5]\n */\nconst arrStep = (arr, step) => arr.filter((val, index) => index % step === 0);\n\n/**\n * Returns an array of all unique elements in an array.\n *\n * @function arrUniq\n * @memberof Array\n * @since 1.0.0\n * @param {any[]} arr\n * @returns {any[]}\n * @example\n * arrUniq([1, 1, 1, 2, 3, 1, 2, 1, 4])\n * // => [1, 2, 3, 4]\n */\nconst arrUniq = (arr) => Array.from(new Set(arr));\n\n/**\n * Maps each entry of an object and returns the result.\n *\n * @function objMap\n * @memberof Object\n * @since 1.0.0\n * @param {Object} obj\n * @param {function} fn fn(key: any, val: any, index: number, obj: object)\n * @returns {Object}\n * @example\n * objMap({a: 4, b: 2}, (key, val) => val * 2)\n * // => {a: 8, b: 4}\n */\nconst objMap = (obj, fn) => {\n    const objNew = {};\n    forEachEntry(obj, (key, val, index) => {\n        objNew[key] = fn(key, val, index, obj);\n    });\n    return objNew;\n};\n\n/**\n * Replaces every circular reference in an object.\n *\n * Can take a custom replacer function and a pre-filled WeakSet of references.\n *\n * @function objDecycle\n * @memberof Object\n * @since 6.0.0\n * @param {Object} obj\n * @param {function} [fn=()=>null] fn(key: any, val: any, index: number, obj: object)\n * @param {WeakSet<any>} [references=new WeakSet()]\n * @returns {Object}\n * @example\n * const a = {b: 1, c: 2};\n *\n * a.a = a;\n *\n * objDecycle(a)\n * // => {a: null, b: 1, c: 2}\n *\n * objDecycle(a,key=>`_${key}`)\n * // => {a: \"_a\", b: 1, c: 2}\n */\nconst objDecycle = (obj, fn = () => null, references = new WeakSet()) => {\n    references.add(obj);\n    return objMap(obj, (key, val, index, objNew) => {\n        if (references.has(val)) {\n            return fn(key, val, index, objNew);\n        }\n        if (isObjectLike(val)) {\n            references.add(val);\n            return objDecycle(val, fn, references);\n        }\n        return val;\n    });\n};\n\n/**\n * Creates a new object with the entries of the input object.\n *\n * @function objFrom\n * @memberof Object\n * @since 1.0.0\n * @param {Object} obj\n * @returns {Object}\n * @example\n * const a = {a: 4, b: 2};\n * const b = objFrom(a);\n *\n * b.a = 10;\n * // a = {a: 4, b: 2}\n * // b = {a: 10, b: 2}\n */\nconst objFrom = (obj) => Object.assign({}, obj);\n\n/**\n * Sets every nil property of object to the value from the default object.\n *\n * @function objDefaults\n * @memberof Object\n * @since 2.6.0\n * @param {Object} obj\n * @param {Object} objDefault\n * @returns {Object}\n * @example\n * objDefaults({a: 1, c: 5}, {a: 1, b: 2, c: 3})\n * // => {a: 1, b: 2, c: 5}\n */\nconst objDefaults = (obj, objDefault) => {\n    const result = isArray(obj)\n        ? Array.from(obj)\n        : objFrom(obj);\n    forEachEntry(objDefault, (keyDefault, valDefault) => {\n        if (isUndefined(obj[keyDefault])) {\n            result[keyDefault] = valDefault;\n        }\n    });\n    return result;\n};\n\n/**\n * Recursively sets every nil property of object to the value from the default object.\n *\n * @function objDefaultsDeep\n * @memberof Object\n * @since 2.7.0\n * @param {Object} obj\n * @param {Object} objDefault\n * @returns {Object}\n * @example\n * objDefaultsDeep({a: [1, 2], c: {f: \"x\"}}, {a: [1, 2, 3], b: 2, c: {f: \"y\"}})\n * // => {a: [1, 2, 3], b: 2, c: {f: \"x\"}}\n */\nconst objDefaultsDeep = (obj, objDefault) => {\n    const result = isArray(obj)\n        ? Array.from(obj)\n        : objFrom(obj);\n    forEachEntry(objDefault, (keyDefault, valDefault) => {\n        const valGiven = obj[keyDefault];\n        if (isObjectLike(valDefault)) {\n            result[keyDefault] = isObjectLike(valGiven)\n                ? objDefaultsDeep(valGiven, valDefault)\n                : valDefault;\n        }\n        else {\n            result[keyDefault] = isUndefined(valGiven) ? valDefault : valGiven;\n        }\n    });\n    return result;\n};\n\n/**\n * Recursively maps each entry of an object and returns the result.\n *\n * @function objMapDeep\n * @memberof Object\n * @since 1.0.0\n * @param {Object} obj\n * @param {function} fn fn(key: any, val: any, index: number, obj: object)\n * @returns {Object}\n * @example\n * arrMapDeep({a: {b: 2, c: [10, 20]}}, (key, val) => val * 2)\n * // => {a: {b: 4, c: [20, 40]}}\n */\nconst objMapDeep = (obj, fn) => objMap(obj, (key, val, index, objNew) => isObjectLike(val)\n    ? objMapDeep(val, fn)\n    : fn(key, val, index, objNew));\n\n/**\n * Recursively creates a new object with the entries of the input object.\n *\n * @function objFromDeep\n * @memberof Object\n * @since 1.0.0\n * @param {Object} obj\n * @returns {Object}\n * @example\n * const a = {a: {b: 2, c: {a: 10, b: 20}}};\n * const b = objFromDeep(a);\n *\n * b.a.c.a = 123;\n * // a = {a: {b: 2, c: {a: 10, b: 20}}\n * // b = {a: {b: 2, c: {a: 123, b: 20}}}\n */\nconst objFromDeep = (obj) => objMapDeep(objFrom(obj), (key, val) => (isObjectLike(val) ? objFrom(val) : val));\n\n/**\n * Creates a map from an object.\n *\n * @function mapFromObject\n * @memberof Map\n * @since 1.0.0\n * @param {Object} obj\n * @returns {Map}\n * @example\n * mapFromObject({a: 1, b: 4, c: 5})\n * // => Map<string,number>{a: 1, b: 4, c: 5}\n */\nconst mapFromObject = (obj) => new Map(Object.entries(obj));\n\n/**\n * Recursively iterates over each element in an array.\n *\n * @function forEachDeep\n * @memberof For\n * @param {any[]} arr\n * @param {function} fn fn(val: any, index: number, arr: any[])\n * @example\n * const a = [2, 4, [1, 1, [16], 4]];\n *\n * forEachDeep(a, (val, index, arr) => arr[index] = index * val)\n * // a = [0, 4, [0, 1, [0], 12]]\n */\nconst forEachDeep = (arr, fn) => arr.forEach((val, index) => isArray(val) ? forEachDeep(val, fn) : fn(val, index, arr));\n\n/**\n * Recursively iterates over each entry of an object.\n *\n * @function forEachEntryDeep\n * @memberof For\n * @param {object} obj\n * @param {function} fn fn(key: any, val: any, index: number, arr: any[])\n * @example\n * const a = {a: 1, b: {c: [1, 2]}};\n *\n * forEachEntryDeep(a, (key, val, index, obj) => obj[key] = index * val)\n * // a = {a: 0, b: {c: [0, 2]}}\n */\nconst forEachEntryDeep = (obj, fn) => forEachEntry(obj, (key, val, index) => isObjectLike(val)\n    ? forEachEntryDeep(val, fn)\n    : fn(key, val, index, obj));\n\n/**\n * Returns a curried function.\n *\n * A curried function can take between zero and n arguments,\n * where n is either the functions argument length or the provided arity.\n * As soon as n arguments are reached, the function is run with all arguments.\n *\n * @function fnCurry\n * @memberof Fn\n * @since 3.2.0\n * @param {Function} fn\n * @param {number} [arity=fn.length]\n * @returns {Function}\n * @example\n * const foo = (a, b, c) => [a, b, c];\n * const fooCurried = fnCurry(foo);\n *\n * fooCurried(1)(2)(3)\n * // => [1, 2, 3]\n *\n * fooCurried(1, 2)(3)\n * // => [1, 2, 3]\n *\n * fooCurried(1, 2, 3)\n * // => [1, 2, 3]\n */\nconst fnCurry = (fn, arity = fn.length) => {\n    // tslint:disable-next-line:only-arrow-functions\n    const resolver = function () {\n        const argsBase = arguments;\n        // tslint:disable-next-line:only-arrow-functions\n        return function () {\n            const args = [...argsBase, ...arguments];\n            const result = args.length >= arity ? fn : resolver;\n            return result(...args);\n        };\n    };\n    return resolver();\n};\n\n/**\n * Creates a debounced function that delays invoking the fn.\n *\n * @function fnDebounce\n * @memberof Fn\n * @param {Function} fn\n * @param {number} timeout\n * @returns {Function}\n * @example\n * const foo = (a, b) => console.log(a + b);\n * const fooThrottled = fnThrottle(foo, 500);\n * // function can only run 500ms after the last invocation was made\n */\nconst fnDebounce = (fn, timeout) => {\n    let timer;\n    // tslint:disable-next-line:only-arrow-functions\n    return function () {\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n            timer = null;\n            fn(...arguments);\n        }, timeout);\n        if (!timer) {\n            fn(...arguments);\n        }\n    };\n};\n\n/**\n * Throttles a function to only run every n ms.\n *\n * Useful for event handlers that fire several times a second, such as scroll or resize.\n *\n * @function fnThrottle\n * @memberof Fn\n * @since 3.1.0\n * @param {Function} fn\n * @param {number} timeout\n * @param {boolean} [immediate=false]\n * @returns {Function}\n * @example\n * const foo = (a, b) => console.log(a + b);\n * const fooThrottled = fnThrottle(foo, 500);\n * // function can only run every 500ms\n */\nconst fnThrottle = (fn, timeout, immediate = false) => {\n    // Private helper that creates a returns a timeout to reset the canRun state and the timer\n    const getTimer = () => setTimeout(() => {\n        canRun = true;\n        clearTimeout(timer);\n    }, timeout);\n    let canRun = immediate;\n    // Has to be set to any because it can either a number (in browsers) or a Timer instance (in NodeJS)\n    let timer = immediate ? -1 : getTimer();\n    // tslint:disable-next-line:only-arrow-functions\n    return function () {\n        if (canRun) {\n            fn(...arguments);\n            canRun = false;\n            timer = getTimer();\n        }\n    };\n};\n\n/**\n * Binary Search implementation.\n *\n * @function searchBinary\n * @memberof Search\n * @since 5.0.0\n * @param {number[]} arr\n * @param {number} search\n * @returns {number|null}\n * @example\n * searchBinary([0, 1, 2], 2)\n * // => 1\n *\n * searchBinary([0, 1, 2], 100)\n * // => null\n */\nconst searchBinary = (arr, search) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let mid;\n    while (low <= high) {\n        mid = Math.floor(low + (high - low) / 2);\n        const current = arr[mid];\n        if (current === search) {\n            return mid;\n        }\n        else if (current < search) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return null;\n};\n\n/**\n * Return a random float or integer number in the given range.\n *\n * @function randNumber\n * @memberof Random\n * @since 3.0.0\n * @param {number} [min=0] inclusive minimum\n * @param {number} [max=1] inclusive maximum\n * @param {boolean} [floating=false]\n * @returns {number}\n * @example\n * randNumber()\n * // => 1\n *\n * randNumber(0, 100)\n * // => 54\n *\n * randNumber(2, 10, true)\n * // => 6.23132496\n */\nconst randNumber = (min = 0, max = 1, floating = false) => {\n    const diff = max - min;\n    if (diff === 0) {\n        return min;\n    }\n    const rand = Math.random() * diff;\n    return min + (floating ? rand : Math.floor((rand / diff) * (diff + 1)));\n};\n\n/**\n * Return a random item from an array.\n *\n * @function randItem\n * @memberof Random\n * @since 3.0.0\n * @param {any[]} arr\n * @returns {any}\n * @example\n * randItem([\"foo\", \"bar\"])\n * // => \"foo\"\n *\n * randItem([1, 2, 3, 4, 5])\n * // => 3\n */\nconst randItem = (arr) => arr[randNumber(0, arr.length - 1)];\n\n/**\n * Shuffles an array randomly and returns it.\n *\n * Fisher-Yates shuffle algorithm.\n *\n * @function randShuffle\n * @memberof Random\n * @since 5.0.0\n * @param {any[]} arr\n * @returns {any[]}\n * @example\n * randShuffle([1,2,3])\n * // => [3,1,2]\n */\nconst randShuffle = (arr) => {\n    const result = Array.from(arr);\n    let length = result.length;\n    while (length--) {\n        const index = randNumber(0, length);\n        const temp = result[length];\n        result[length] = result[index];\n        result[index] = temp;\n    }\n    return result;\n};\n\n/**\n * Value checking, type checking, and comparison\n * @namespace Is\n */\n/**\n * Check if a target has something\n * @namespace Has\n */\n/**\n * Get value from a target\n * @namespace Get\n */\n/**\n * Number manipulation and comparison\n * @namespace Number\n */\n/**\n * String manipulation and comparison\n * @namespace String\n */\n/**\n * Array manipulation and analysis\n * @namespace Array\n */\n/**\n * Object manipulation and analysis\n * @namespace Object\n */\n/**\n * Map manipulation\n * @namespace Map\n */\n/**\n * Looping through ranges, arrays and objects\n * @namespace For\n */\n/**\n * Function manipulation\n * @namespace Fn\n */\n/**\n * Array and object search\n * @namespace Search\n */\n/**\n * Random number generation and value picking\n * @namespace Random\n */\n\nexport { isEqual, isInstanceOf, isTypeOf, isUndefined, isNull, isNil, isNumber, isString, isBoolean, isSymbol, isObject, isObjectLike, isObjectPlain, isArray, isArrayLike, isArrayBuffer, isArrayTyped, isPromise, isMap, isSet, isDate, isRegExp, isFunction, isArguments, isError, isEmpty, isIndex, hasPath, getPath, getSize, numClamp, numSum, numAverage, numMedian, numSafe, strDistance, strSimilar, strFromCamelCase, strFromKebabCase, strFromPascalCase, strFromSnakeCase, strToCamelCase, strToKebabCase, strToPascalCase, strToSnakeCase, arrFromDeep, arrMapDeep, arrCompact, arrChunk, arrStep, arrRemoveIndex, arrRemoveItem, arrRemoveFirstItem, arrCount, arrCollect, arrDifference, arrIntersection, arrUniq, objFrom, objFromDeep, objMap, objMapDeep, objDefaults, objDefaultsDeep, objDecycle, mapFromObject, fnCurry, fnDebounce, fnThrottle, forEachDeep, forEachEntry, forEachEntryDeep, searchBinary, randNumber, randItem, randShuffle };\n"],"names":["root","definition","define","amd","module","exports","log","this","bindMethod","obj","methodName","method","bind","Function","prototype","call","e","apply","arguments","realMethod","console","undefinedType","undefined","noop","replaceLoggingMethods","level","loggerName","i","logMethods","length","methodFactory","debug","enableLoggingWhenConsoleArrives","defaultMethodFactory","Logger","name","defaultLevel","factory","persistLevelIfPossible","levelNum","levelName","toUpperCase","window","localStorage","storageKey","ignore","document","cookie","encodeURIComponent","getPersistedLevel","storedLevel","location","indexOf","exec","slice","self","levels","currentLevel","TRACE","DEBUG","INFO","WARN","ERROR","SILENT","getLevel","setLevel","persist","setDefaultLevel","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers","isNil","val","strDistance","str1","str2","str1Length","str2Length","matrix","y","x","matrixColumnCurrent","matrixColumnLast","charAt","substitution","insertion","deletion","Math","min","arrCollect","arr","fn","result","Map","forEach","index","key","set","has","get","strSimilar","str","list","returnFull","keys"],"mappings":"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"}