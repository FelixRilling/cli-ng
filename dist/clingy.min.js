var clingy=function(t){"use strict";const e=(t,e)=>t instanceof e,n=t=>null==t,s=(t,e)=>typeof t===e,i=t=>e(t,Map),r=t=>!n(t)&&(s(t,"object")||s(t,"function")),o=(t,e)=>{if(0===t.length)return e.length;if(0===e.length)return t.length;const n=[];for(let t=0;t<=e.length;t++)n[t]=[t];for(let e=0;e<=t.length;e++)n[0][e]=e;for(let s=1;s<=e.length;s++){const i=n[s],r=n[s-1];for(let n=1;n<=t.length;n++)if(e.charAt(s-1)===t.charAt(n-1))i[n]=r[n-1];else{const t=r[n-1]+1,e=i[n-1]+1,s=r[n]+1;i[n]=Math.min(t,e,s)}}return n[e.length][t.length]},a=t=>t.filter(t=>t),g=(t,e)=>{const s=new Map;t.forEach((i,r)=>{const o=e(i,r,t);n(o)||s.set(o,s.has(o)?[...s.get(o),i]:[i])});return s},u=(t,e,n=!1)=>{const s=g(e,e=>o(t,e));return n?s:s.get(Math.min(...s.keys()))},l=t=>{if(i(t))return Array.from(t.entries());if(r(t))return Array.from(Object.entries(t));return null};class h extends Map{constructor(t){super(l(t))}hasIgnoreCase(t){return Array.from(this.keys()).map(t=>t.toLowerCase()).includes(t.toLowerCase())}getIgnoreCase(t){let e=null;return this.forEach((n,s)=>{t.toLowerCase()===s.toLowerCase()&&(e=n)}),e}}const c={NONE:{val:-1},ERROR:{val:0,name:"ERROR"},WARN:{val:1,name:"WARN"},INFO:{val:2,name:"INFO"},DEBUG:{val:3,name:"DEBUG"},TRACE:{val:4,name:"TRACE"}},f=(t,e)=>typeof t===e,p=t=>f(t,"string");class m{constructor(t,e){this.root=t,this.name=e}log(t,...e){this.root.level.val>=t.val&&this.root.appenderQueue.forEach(n=>n(t,this.name,e))}error(...t){this.log(c.ERROR,t)}warn(...t){this.log(c.WARN,t)}info(...t){this.log(c.INFO,t)}debug(...t){this.log(c.DEBUG,t)}trace(...t){this.log(c.TRACE,t)}}const d=(t,e,n)=>console.log(`${(new Date).toISOString()} ${t.name} ${e} - ${n[0]}`,...n.slice(1));class w{constructor(t=c.INFO){this.loggerMap=new Map,this.level=t,this.appenderQueue=[d]}getLogger(t){let e;if("name"in t)e=t.name;else{if(!p(t))throw new TypeError(`'${t}' is neither an INameable nor a string.`);e=t}if(this.loggerMap.has(e))return this.loggerMap.get(e);const n=new m(this,e);return this.loggerMap.set(e,n),n}}const v=new w;class A{constructor(t,e){this.missing=[],this.result=new Map;const s=v.getLogger(A);s.debug(`Matching arguments ${t} with ${e}`),t.forEach((t,i)=>{if(i<e.length){const n=e[i];s.trace(`Found matching argument for ${t.name}, adding to result: ${n}`),this.result.set(t.name,n)}else t.required||n(t.defaultValue)?(s.trace(`No matching argument found for ${t.name}, adding to missing.`),this.missing.push(t)):(s.trace(`No matching argument found for ${t.name}, using default: ${t.defaultValue}`),this.result.set(t.name,t.defaultValue))}),s.debug(`Finished matching arguments: ${t.length} expected, ${this.result.size} found and ${this.missing.length} missing.`)}}const R=(t,e)=>u(e,Array.from(t.keys()),!1);class b{constructor(t=!0){this.logger=v.getLogger(b),this.caseSensitive=t}resolve(t,e,n=!1){if(0===e.length)throw new Error("Path cannot be empty.");return this.resolveInternal(t,e,[],n)}resolveInternal(t,e,s,i){const r=e[0],o=e.slice(1);if(s.push(r),this.caseSensitive?!t.has(r):!t.hasIgnoreCase(r))return this.logger.warn(`Command '${r}' could not be found.`),{successful:!1,pathUsed:s,pathDangling:o,type:1,missing:r,similar:R(t,r)};const a=this.caseSensitive?t.get(r):t.getIgnoreCase(r);if(this.logger.debug(`Successfully looked up command: ${r}`),o.length>0&&!n(a.sub))return this.logger.debug(`Resolving sub-commands: ${a.sub} ${o}`),this.resolveInternal(a.sub.mapAliased,o,s,i);let g;if(!i||n(a.args)||0===a.args.length)this.logger.debug("No arguments defined, using empty list."),g=new Map;else{this.logger.debug(`Looking up arguments: ${o}`);const t=new A(a.args,o);if(t.missing.length>0)return this.logger.warn(`Some arguments could not be found: ${t.missing.map(t=>t.name)}`),{successful:!1,pathUsed:s,pathDangling:o,type:2,missing:t.missing};g=t.result,this.logger.debug(`Successfully looked up arguments: ${g}`)}const u={successful:!0,pathUsed:s,pathDangling:o,type:0,command:a,args:g};return this.logger.debug(`Returning successful lookup result: ${u}`),u}}class E{constructor(t=['"']){this.logger=v.getLogger(E),this.legalQuotes=t,this.pattern=this.generateMatcher()}parse(t){this.logger.debug(`Parsing input '${t}'`);const e=[],n=new RegExp(this.pattern);let s;for(;s=n.exec(t);){this.logger.trace(`Found match '${s}'`);const t=a(s.slice(1));t.length>0&&(this.logger.trace(`Found group '${t[0]}'`),e.push(t[0]))}return e}generateMatcher(){this.logger.debug("Creating matcher.");const t=this.legalQuotes.map(t=>`\\${t}`).map(t=>`${t}(.+?)${t}`);t.push("(\\S+)");let e;try{e=new RegExp(t.join("|"),"g")}catch(t){throw this.logger.error("The parsing pattern is invalid, this should never happen.",t),t}return e}}class y{constructor(t={},e={}){this.loggerRoot=v,this.logger=v.getLogger(y),this.lookupResolver=new b(e.caseSensitive),this.inputParser=new E(e.legalQuotes),this.map=new h(t),this.mapAliased=new h,this.updateAliases()}setCommand(t,e){this.map.set(t,e),this.updateAliases()}getCommand(t){return this.mapAliased.get(t)}hasCommand(t){return this.mapAliased.has(t)}hasPath(t){return this.getPath(t).successful}getPath(t){return this.logger.debug(`Resolving pathUsed: ${t}`),this.lookupResolver.resolve(this.mapAliased,t)}parse(t){return this.logger.debug(`Parsing input: '${t}'`),this.lookupResolver.resolve(this.mapAliased,this.inputParser.parse(t),!0)}updateAliases(){this.logger.debug("Updating aliased map."),this.mapAliased.clear(),this.map.forEach((t,e)=>{this.mapAliased.set(e,t);t.alias.forEach(n=>{this.mapAliased.has(n)?this.logger.warn(`Alias '${n}' conflicts with a previously defined key, will be ignored.`):(this.logger.trace(`Created alias '${n}' for '${e}'`),this.mapAliased.set(n,t))})}),this.logger.debug("Done updating aliased map.")}}return t.Clingy=y,t}({});
//# sourceMappingURL=clingy.min.js.map
