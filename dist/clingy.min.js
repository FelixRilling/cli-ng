var clingy=function(e){"use strict";const n=(e,...n)=>n.some(n=>e instanceof n),t=(e,...n)=>n.some(n=>typeof e===n),s=e=>null==e,i=e=>!s(e)&&t(e,"object"),o=(e,n)=>{for(const[t,s]of Object.entries(e))n(s,t,e)},r=e=>t(e,"function"),u=e=>n(e,Map),a=e=>i(e)||r(e),g=e=>a(e)&&e.constructor===Object,c=(e,n)=>{if(0===e.length)return n.length;if(0===n.length)return e.length;const t=[];for(let e=0;e<=n.length;e++)t[e]=[e];for(let n=0;n<=e.length;n++)t[0][n]=n;for(let s=1;s<=n.length;s++){const i=t[s],o=t[s-1];for(let t=1;t<=e.length;t++)if(n.charAt(s-1)===e.charAt(t-1))i[t]=o[t-1];else{const e=o[t-1]+1,n=i[t-1]+1,s=o[t]+1;i[t]=Math.min(e,n,s)}}return t[n.length][e.length]},l=e=>e.filter(e=>e),f=(e,n)=>{const t=new Map;e.forEach((i,o)=>{const r=n(i,o,e);s(r)||t.set(r,t.has(r)?[...t.get(r),i]:[i])});return t},h=(e,n,t=!1)=>{const s=f(n,n=>c(e,n));if(!t)return s.get(Math.min(...s.keys()));return s};class p extends Map{constructor(e){super(p.getConstructorMap(e))}static createWithOptions(e,n){return u(e)?e.forEach(e=>p.createWithOptionsHelper(e,n)):g(e)&&o(e,e=>p.createWithOptionsHelper(e,n)),new p(e)}static createWithOptionsHelper(e,n){(g(e.sub)||u(e.sub))&&(e.sub=new L(p.createWithOptions(e.sub,n),n))}static getConstructorMap(e){return u(e)?Array.from(e.entries()):a(e)?Array.from(Object.entries(e)):null}hasIgnoreCase(e){return Array.from(this.keys()).map(e=>e.toLowerCase()).includes(e.toLowerCase())}getIgnoreCase(e){let n=null;return this.forEach((t,s)=>{e.toLowerCase()===s.toLowerCase()&&(n=t)}),n}}const m={NONE:{val:-1},ERROR:{name:"ERROR",val:0},WARN:{name:"WARN",val:1},INFO:{name:"INFO",val:2},DEBUG:{name:"DEBUG",val:3},TRACE:{name:"TRACE",val:4}},d=(e,n,t)=>{let s=console.log;e===m.ERROR?s=console.error:e===m.WARN?s=console.warn:e===m.INFO&&(s=console.info);s(`${(new Date).toISOString()} ${e.name} ${n}`,...t)},b=(e,...n)=>n.some(n=>typeof e===n),w=e=>null==e,R=e=>!w(e)&&b(e,"object"),v=e=>b(e,"string"),A=e=>b(e,"function"),E=e=>R(e)||A(e);class y{constructor(e,n){this.root=e,this.name=n}log(e,...n){this.root.getLevel().val>=e.val&&this.root.getAppenders().forEach(t=>t(e,this.name,n))}error(...e){this.log(m.ERROR,...e)}warn(...e){this.log(m.WARN,...e)}info(...e){this.log(m.INFO,...e)}debug(...e){this.log(m.DEBUG,...e)}trace(...e){this.log(m.TRACE,...e)}}class O{constructor(){this.loggers=new Map,this.appenders=new Map([["defaultAppender",d]]),this.level=m.INFO}getLogger(e){let n;if(E(e)&&"name"in e)n=e.name;else{if(!v(e))throw new TypeError(`'${e}' is neither an INameable nor a string.`);n=e}if(this.loggers.has(n))return this.loggers.get(n);const t=new y(this,n);return this.loggers.set(n,t),t}getLevel(){return this.level}setLevel(e){this.level=e}attachAppender(e,n){this.appenders.set(e,n)}detachAppender(e){this.appenders.delete(e)}getAppenders(){return this.appenders}}const M=new O;class N{constructor(e,n){this.missing=[],this.result=new Map,N.logger.debug("Matching arguments:",e,n),e.forEach((e,t)=>{if(t<n.length){const s=n[t];N.logger.trace(`Found matching argument for ${e.name}, adding to result: ${s}`),this.result.set(e.name,s)}else e.required||s(e.defaultValue)?(N.logger.trace(`No matching argument found for ${e.name}, adding to missing.`),this.missing.push(e)):(N.logger.trace(`No matching argument found for ${e.name}, using default: ${e.defaultValue}`),this.result.set(e.name,e.defaultValue))}),N.logger.debug(`Finished matching arguments: ${e.length} expected, ${this.result.size} found and ${this.missing.length} missing.`)}}N.logger=M.getLogger(N);const C=(e,n)=>h(n,Array.from(e.keys()),!1);class I{constructor(e=!0){this.caseSensitive=e}resolve(e,n,t=!1){if(0===n.length)throw new Error("Path cannot be empty.");return this.resolveInternal(e,n,[],t)}resolveInternal(e,t,i,o){const r=t[0],u=t.slice(1);if(i.push(r),this.caseSensitive?!e.has(r):!e.hasIgnoreCase(r))return I.createNotFoundResult(u,i,r,e);const a=this.caseSensitive?e.get(r):e.getIgnoreCase(r);I.logger.debug(`Successfully looked up command: ${r}`);let g;if(!o||s(a.args)||0===a.args.length){if(u.length>0&&n(a.sub,L))return this.resolveInternalSub(u,i,a,o);I.logger.debug("No arguments defined, using empty map."),g=new Map}else{I.logger.debug(`Looking up arguments: ${u}`);const e=new N(a.args,u);if(e.missing.length>0)return I.createMissingArgsResult(u,i,e.missing);g=e.result,I.logger.debug("Successfully looked up arguments:",g)}return I.createSuccessResult(u,i,a,g)}resolveInternalSub(e,n,t,s){return I.logger.debug("Resolving sub-commands:",t.sub,e),this.resolveInternal(t.sub.mapAliased,e,n,s)}static createSuccessResult(e,n,t,s){const i={successful:!0,pathUsed:n,pathDangling:e,type:0,command:t,args:s};return I.logger.debug("Returning successful lookup result:",i),i}static createNotFoundResult(e,n,t,s){return I.logger.warn(`Command '${t}' could not be found.`),{successful:!1,pathUsed:n,pathDangling:e,type:1,missing:t,similar:C(s,t)}}static createMissingArgsResult(e,n,t){return I.logger.warn("Some arguments could not be found:",t),{successful:!1,pathUsed:n,pathDangling:e,type:2,missing:t}}}I.logger=M.getLogger(I);class S{constructor(e=['"']){this.legalQuotes=e,this.pattern=this.generateMatcher()}parse(e){S.logger.debug(`Parsing input '${e}'`);const n=[],t=new RegExp(this.pattern);let s;for(;s=t.exec(e);){S.logger.trace(`Found match '${s}'`);const e=l(s.slice(1));e.length>0&&(S.logger.trace(`Found group '${e[0]}'`),n.push(e[0]))}return n}generateMatcher(){S.logger.debug("Creating matcher.");const e=this.legalQuotes.map(e=>`\\${e}`).map(e=>`${e}(.+?)${e}`);e.push("(\\S+)");let n;try{n=new RegExp(e.join("|"),"g")}catch(e){throw S.logger.error("The parsing pattern is invalid, this should never happen.",e),e}return n}}S.logger=M.getLogger(S);class L{constructor(e={},n={}){this.lookupResolver=new I(n.caseSensitive),this.inputParser=new S(n.legalQuotes),this.map=p.createWithOptions(e,n),this.mapAliased=new p,this.updateAliases()}setCommand(e,n){this.map.set(e,n),this.updateAliases()}getCommand(e){return this.mapAliased.get(e)}hasCommand(e){return this.mapAliased.has(e)}hasPath(e){return this.getPath(e).successful}getPath(e){return L.logger.debug(`Resolving pathUsed: ${e}`),this.lookupResolver.resolve(this.mapAliased,e)}parse(e){return L.logger.debug(`Parsing input: '${e}'`),this.lookupResolver.resolve(this.mapAliased,this.inputParser.parse(e),!0)}updateAliases(){L.logger.debug("Updating aliased map."),this.mapAliased.clear(),this.map.forEach((e,n)=>{this.mapAliased.set(n,e);e.alias.forEach(t=>{this.mapAliased.has(t)?L.logger.warn(`Alias '${t}' conflicts with a previously defined key, will be ignored.`):(L.logger.trace(`Created alias '${t}' for '${n}'`),this.mapAliased.set(t,e))})}),L.logger.debug("Done updating aliased map.")}}return L.logger=M.getLogger(L),e.Clingy=L,e.clingyLogby=M,e}({});
//# sourceMappingURL=clingy.min.js.map
