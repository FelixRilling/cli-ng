var Clingy=function(){"use strict";class e extends Map{hasIgnoreCase(e){return Array.from(this.keys()).map(e=>e.toLowerCase()).includes(e.toLowerCase())}getIgnoreCase(e){return this.forEach((t,n)=>{if(e.toLowerCase()===n.toLowerCase())return t}),null}}var t;!function(e){e[e.ERROR=0]="ERROR",e[e.WARN=1]="WARN",e[e.INFO=2]="INFO",e[e.DEBUG=3]="DEBUG",e[e.TRACE=4]="TRACE"}(t||(t={}));let n=t.INFO;class s{constructor(e){this.name=e}error(...e){n>=t.ERROR&&console.error(this.getPrefix("ERROR"),...e)}warn(...e){n>=t.WARN&&console.warn(this.getPrefix("WARN"),...e)}info(...e){n>=t.INFO&&console.info(this.getPrefix("INFO"),...e)}debug(...e){n>=t.DEBUG&&console.log(this.getPrefix("DEBUG"),...e)}trace(...e){n>=t.TRACE&&console.log(this.getPrefix("TRACE"),...e)}getPrefix(e){return`${(new Date).toISOString()} ${e} ${this.name} - `}}const i={level:n,getLogger:e=>new s("name"in e?e.name:e)},r=e=>null==e,o=(e,t)=>{const n=e.length;const s=t.length;if(0===n)return s;if(0===s)return n;const i=[];for(let e=0;e<=s;e++)i[e]=[e];for(let e=0;e<=n;e++)i[0][e]=e;for(let r=1;r<=s;r++){const s=i[r],o=i[r-1];for(let i=1;i<=n;i++)if(t.charAt(r-1)===e.charAt(i-1))s[i]=o[i-1];else{const e=o[i-1]+1,t=s[i-1]+1,n=o[i]+1;s[i]=Math.min(e,t,n)}}return i[s][n]},a=(e,t)=>{const n=new Map;e.forEach((s,i)=>{const r=t(s,i,e);n.set(r,n.has(r)?[...n.get(r),s]:[s])});return n},u=(e,t,n=!1)=>{const s=a(t,t=>o(e,t));return n?s:s.get(Math.min(...s.keys()))};class g{constructor(e,t){this.missing=[],this.result=new Map;const n=i.getLogger(g);n.debug("Matching arguments {} with {}",e,t),e.forEach((e,s)=>{s<t.length?(n.trace("Found matching argument for {}, adding to result: {}",e.name,t[s]),this.result.set(e.name,t[s])):e.required?(n.trace("No matching argument found for {}, adding to missing.",e.name),this.missing.push(e)):(n.trace("No matching argument found for {}, using default: {}",e.name,e.defaultValue),this.result.set(e.name,e.defaultValue))}),n.debug("Finished matching arguments: {} expected, {} found and {} missing.",e.length,this.result.size,this.missing.length)}}const h=(e,t)=>u(t,Array.from(e.keys()),!1);class l{constructor(e=!0){this.logger=i.getLogger(l),this.caseSensitive=e}resolve(e,t,n=!1){return this.resolveInternal(e,t,[],n)}resolveInternal(e,t,n,s=!1){if(0===t.length)throw new Error("Path cannot be empty.");const i=t[0],o=t.slice(1);if(n.push(i),this.caseSensitive?!e.has(i):!e.hasIgnoreCase(i))return this.logger.warn("Command '{}' could not be found.",i),{successful:!1,pathUsed:n,pathDangling:o,type:1,missing:i,similar:h(e,i)};const a=this.caseSensitive?e.get(i):e.getIgnoreCase(i);this.logger.debug("Successfully looked up command: {}",i);let u;if(!s||r(a.args)||0===a.args.length)this.logger.debug("No arguments defined, using empty list."),u=new Map;else{this.logger.debug("Looking up arguments: {}",o);const e=new g(a.args,o);if(e.missing.length>0)return this.logger.warn("Some arguments could not be found: {}",e.missing),{successful:!1,pathUsed:n,pathDangling:o,type:2,missing:e.missing};u=e.result,this.logger.debug("Successfully looked up arguments: {}",u)}const l={successful:!0,pathUsed:n,pathDangling:o,type:0,command:a,args:u};return this.logger.debug("Returning successful lookup result: {}",l),l}}class c{constructor(e=['"']){this.logger=i.getLogger(c),this.legalQuotes=e,this.pattern=this.generateMatcher()}static escapeRegexCharacter(e){return`\\Q${e}\\E`}parse(e){return this.logger.debug("Parsing input '{}'",e),Array.from(e.match(this.pattern))}generateMatcher(){this.logger.debug("Creating matcher.");const e=this.legalQuotes.map(c.escapeRegexCharacter).map(e=>`${e}(.+?)${e}`);e.push("(\\S+)");let t;try{t=new RegExp(e.join("|"),"")}catch(e){throw this.logger.error("The parsing pattern is invalid, this should never happen.",e),e}return t}}class f{constructor(t=new e,n=!0,s=['"']){this.logger=i.getLogger(f),this.lookupResolver=new l(n),this.inputParser=new c(s),this.map=t,this.mapAliased=new e,this.updateAliases()}setCommand(e,t){this.map.set(e,t),this.updateAliases()}getCommand(e){return this.mapAliased.get(e)}hasCommand(e){return this.mapAliased.has(e)}hasPath(e){const t=this.getPath(e);return null!=t&&t.successful}getPath(e){return this.logger.debug("Resolving pathUsed: {}",e),this.lookupResolver.resolve(this.mapAliased,e)}parse(e){return this.logger.debug("Parsing input: '{}'",e),this.lookupResolver.resolve(this.mapAliased,this.inputParser.parse(e),!0)}updateAliases(){this.logger.debug("Updating aliased map."),this.mapAliased.clear(),this.map.forEach((e,t)=>{this.mapAliased.set(t,e);e.alias.forEach(n=>{this.mapAliased.has(n)?this.logger.warn("Alias '{}' conflicts with a previously defined key, will be ignored.",n):(this.logger.trace("Created alias '{}' for '{}'",n,t),this.mapAliased.set(n,e))})}),this.logger.debug("Done updating aliased map.")}}return f}();
//# sourceMappingURL=clingy.min.js.map
