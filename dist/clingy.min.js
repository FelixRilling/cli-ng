var clingy=function(t){"use strict";const e=(t,e)=>t instanceof e,n=t=>null==t,s=(t,e)=>typeof t===e,i=t=>s(t,"string"),r=t=>e(t,Map),o=t=>!n(t)&&(s(t,"object")||s(t,"function")),a=(t,e)=>{if(0===t.length)return e.length;if(0===e.length)return t.length;const n=[];for(let t=0;t<=e.length;t++)n[t]=[t];for(let e=0;e<=t.length;e++)n[0][e]=e;for(let s=1;s<=e.length;s++){const i=n[s],r=n[s-1];for(let n=1;n<=t.length;n++)if(e.charAt(s-1)===t.charAt(n-1))i[n]=r[n-1];else{const t=r[n-1]+1,e=i[n-1]+1,s=r[n]+1;i[n]=Math.min(t,e,s)}}return n[e.length][t.length]},g=(t,e)=>{const s=new Map;t.forEach((i,r)=>{const o=e(i,r,t);n(o)||s.set(o,s.has(o)?[...s.get(o),i]:[i])});return s},u=(t,e,n=!1)=>{const s=g(e,e=>a(t,e));return n?s:s.get(Math.min(...s.keys()))},h=t=>{if(r(t))return Array.from(t.entries());if(o(t))return Array.from(Object.entries(t));return null};class l extends Map{constructor(t){super(h(t))}hasIgnoreCase(t){return Array.from(this.keys()).map(t=>t.toLowerCase()).includes(t.toLowerCase())}getIgnoreCase(t){let e=null;return this.forEach((n,s)=>{t.toLowerCase()===s.toLowerCase()&&(e=n)}),e}}var c;!function(t){t[t.ERROR=0]="ERROR",t[t.WARN=1]="WARN",t[t.INFO=2]="INFO",t[t.DEBUG=3]="DEBUG",t[t.TRACE=4]="TRACE"}(c||(c={}));class f{constructor(t,e){this.name=t,this.instance=e}error(...t){this.log(c.ERROR,"ERROR","error",t)}warn(...t){this.log(c.WARN,"WARN","warn",t)}info(...t){this.log(c.INFO,"INFO","info",t)}debug(...t){this.log(c.DEBUG,"DEBUG","log",t)}trace(...t){this.log(c.TRACE,"TRACE","log",t)}log(t,e,n,s){this.instance.level>=t&&this.instance.stdout[n](`${(new Date).toISOString()} ${e} ${this.name} -`,...s)}}class p{constructor(t=c.INFO,e=console){this.loggerMap=new Map,this.level=t,this.stdout=e}getLogger(t){let e;if("name"in t)e=t.name;else{if(!i(t))throw new TypeError(`'${t}' is neither an INameable nor a string.`);e=t}if(this.loggerMap.has(e))return this.loggerMap.get(e);const n=new f(e,this);return this.loggerMap.set(e,n),n}}const m=new p;class d{constructor(t,e){this.missing=[],this.result=new Map;const s=m.getLogger(d);s.debug(`Matching arguments ${t} with ${e}`),t.forEach((t,i)=>{if(i<e.length){const n=e[i];s.trace(`Found matching argument for ${t.name}, adding to result: ${n}`),this.result.set(t.name,n)}else t.required||n(t.defaultValue)?(s.trace(`No matching argument found for ${t.name}, adding to missing.`),this.missing.push(t)):(s.trace(`No matching argument found for ${t.name}, using default: ${t.defaultValue}`),this.result.set(t.name,t.defaultValue))}),s.debug(`Finished matching arguments: ${t.length} expected, ${this.result.size} found and ${this.missing.length} missing.`)}}const w=(t,e)=>u(e,Array.from(t.keys()),!1);class A{constructor(t=!0){this.logger=m.getLogger(A),this.caseSensitive=t}resolve(t,e,n=!1){return this.resolveInternal(t,e,[],n)}resolveInternal(t,e,s,i){if(0===e.length)throw new Error("Path cannot be empty.");const r=e[0],o=e.slice(1);if(s.push(r),this.caseSensitive?!t.has(r):!t.hasIgnoreCase(r))return this.logger.warn(`Command '${r}' could not be found.`),{successful:!1,pathUsed:s,pathDangling:o,type:1,missing:r,similar:w(t,r)};const a=this.caseSensitive?t.get(r):t.getIgnoreCase(r);this.logger.debug(`Successfully looked up command: ${r}`);let g;if(!i||n(a.args)||0===a.args.length)this.logger.debug("No arguments defined, using empty list."),g=new Map;else{this.logger.debug(`Looking up arguments: ${o}`);const t=new d(a.args,o);if(t.missing.length>0)return this.logger.warn(`Some arguments could not be found: ${t.missing}`),{successful:!1,pathUsed:s,pathDangling:o,type:2,missing:t.missing};g=t.result,this.logger.debug(`Successfully looked up arguments: ${g}`)}const u={successful:!0,pathUsed:s,pathDangling:o,type:0,command:a,args:g};return this.logger.debug(`Returning successful lookup result: ${u}`),u}}class R{constructor(t=['"']){this.logger=m.getLogger(R),this.legalQuotes=t,this.pattern=this.generateMatcher()}parse(t){return this.logger.debug(`Parsing input '${t}'`),Array.from(t.match(this.pattern))}generateMatcher(){this.logger.debug("Creating matcher.");const t=this.legalQuotes.map(t=>`\\Q${t}\\E`).map(t=>`${t}(.+?)${t}`);t.push("(\\S+)");let e;try{e=new RegExp(t.join("|"),"g")}catch(t){throw this.logger.error("The parsing pattern is invalid, this should never happen.",t),t}return e}}class E{constructor(t=new Map,e=!0,n=['"']){this.loggerGroup=m,this.logger=m.getLogger(E),this.lookupResolver=new A(e),this.inputParser=new R(n),this.map=new l(t),this.mapAliased=new l,this.updateAliases()}setCommand(t,e){this.map.set(t,e),this.updateAliases()}getCommand(t){return this.mapAliased.get(t)}hasCommand(t){return this.mapAliased.has(t)}hasPath(t){return this.getPath(t).successful}getPath(t){return this.logger.debug(`Resolving pathUsed: ${t}`),this.lookupResolver.resolve(this.mapAliased,t)}parse(t){return this.logger.debug(`Parsing input: '${t}'`),this.lookupResolver.resolve(this.mapAliased,this.inputParser.parse(t),!0)}updateAliases(){this.logger.debug("Updating aliased map."),this.mapAliased.clear(),this.map.forEach((t,e)=>{this.mapAliased.set(e,t);t.alias.forEach(n=>{this.mapAliased.has(n)?this.logger.warn(`Alias '${n}' conflicts with a previously defined key, will be ignored.`):(this.logger.trace(`Created alias '${n}' for '${e}'`),this.mapAliased.set(n,t))})}),this.logger.debug("Done updating aliased map.")}}return t.Clingy=E,t}({});
//# sourceMappingURL=clingy.min.js.map
