var clingy=function(e){"use strict";const t=(e,t)=>e instanceof t,n=e=>null==e,s=(e,t)=>typeof e===t,i=e=>t(e,Map),o=e=>!n(e)&&(s(e,"object")||s(e,"function")),r=(e,t)=>{if(0===e.length)return t.length;if(0===t.length)return e.length;const n=[];for(let e=0;e<=t.length;e++)n[e]=[e];for(let t=0;t<=e.length;t++)n[0][t]=t;for(let s=1;s<=t.length;s++){const i=n[s],o=n[s-1];for(let n=1;n<=e.length;n++)if(t.charAt(s-1)===e.charAt(n-1))i[n]=o[n-1];else{const e=o[n-1]+1,t=i[n-1]+1,s=o[n]+1;i[n]=Math.min(e,t,s)}}return n[t.length][e.length]},a=e=>e.filter(e=>e),g=(e,t)=>{const s=new Map;e.forEach((i,o)=>{const r=t(i,o,e);n(r)||s.set(r,s.has(r)?[...s.get(r),i]:[i])});return s},u=(e,t,n=!1)=>{const s=g(t,t=>r(e,t));return n?s:s.get(Math.min(...s.keys()))},l=e=>{if(i(e))return Array.from(e.entries());if(o(e))return Array.from(Object.entries(e));return null};class c extends Map{constructor(e){super(l(e))}hasIgnoreCase(e){return Array.from(this.keys()).map(e=>e.toLowerCase()).includes(e.toLowerCase())}getIgnoreCase(e){let t=null;return this.forEach((n,s)=>{e.toLowerCase()===s.toLowerCase()&&(t=n)}),t}}const h={NONE:{val:-1},ERROR:{val:0,name:"ERROR"},WARN:{val:1,name:"WARN"},INFO:{val:2,name:"INFO"},DEBUG:{val:3,name:"DEBUG"},TRACE:{val:4,name:"TRACE"}},f=e=>null==e,p=(e,t)=>typeof e===t,m=e=>p(e,"string"),d=e=>!f(e)&&(p(e,"object")||p(e,"function"));class w{constructor(e,t){this.root=e,this.name=t}log(e,...t){this.root.level.val>=e.val&&this.root.appenderQueue.forEach(n=>n(e,this.name,t))}error(...e){this.log(h.ERROR,e)}warn(...e){this.log(h.WARN,e)}info(...e){this.log(h.INFO,e)}debug(...e){this.log(h.DEBUG,e)}trace(...e){this.log(h.TRACE,e)}}const v=(e,t,n)=>console.log(`${(new Date).toISOString()} ${e.name} ${t}`,...n);class A{constructor(e=h.INFO){this.loggerMap=new Map,this.level=e,this.appenderQueue=[v]}getLogger(e){let t;if(d(e)&&"name"in e)t=e.name;else{if(!m(e))throw new TypeError(`'${e}' is neither an INameable nor a string.`);t=e}if(this.loggerMap.has(t))return this.loggerMap.get(t);const n=new w(this,t);return this.loggerMap.set(t,n),n}}const b=new A;class R{constructor(e,t){this.missing=[],this.result=new Map,R.logger.debug(`Matching arguments ${e} with ${t}`),e.forEach((e,s)=>{if(s<t.length){const n=t[s];R.logger.trace(`Found matching argument for ${e.name}, adding to result: ${n}`),this.result.set(e.name,n)}else e.required||n(e.defaultValue)?(R.logger.trace(`No matching argument found for ${e.name}, adding to missing.`),this.missing.push(e)):(R.logger.trace(`No matching argument found for ${e.name}, using default: ${e.defaultValue}`),this.result.set(e.name,e.defaultValue))}),R.logger.debug(`Finished matching arguments: ${e.length} expected, ${this.result.size} found and ${this.missing.length} missing.`)}}R.logger=b.getLogger(R);const E=(e,t)=>u(t,Array.from(e.keys()),!1);class y{constructor(e=!0){this.caseSensitive=e}resolve(e,t,n=!1){if(0===t.length)throw new Error("Path cannot be empty.");return this.resolveInternal(e,t,[],n)}resolveInternal(e,t,s,i){const o=t[0],r=t.slice(1);if(s.push(o),this.caseSensitive?!e.has(o):!e.hasIgnoreCase(o))return y.logger.warn(`Command '${o}' could not be found.`),{successful:!1,pathUsed:s,pathDangling:r,type:1,missing:o,similar:E(e,o)};const a=this.caseSensitive?e.get(o):e.getIgnoreCase(o);if(y.logger.debug(`Successfully looked up command: ${o}`),r.length>0&&!n(a.sub))return y.logger.debug(`Resolving sub-commands: ${a.sub} ${r}`),this.resolveInternal(a.sub.mapAliased,r,s,i);let g;if(!i||n(a.args)||0===a.args.length)y.logger.debug("No arguments defined, using empty list."),g=new Map;else{y.logger.debug(`Looking up arguments: ${r}`);const e=new R(a.args,r);if(e.missing.length>0)return y.logger.warn(`Some arguments could not be found: ${e.missing.map(e=>e.name)}`),{successful:!1,pathUsed:s,pathDangling:r,type:2,missing:e.missing};g=e.result,y.logger.debug(`Successfully looked up arguments: ${g}`)}const u={successful:!0,pathUsed:s,pathDangling:r,type:0,command:a,args:g};return y.logger.debug(`Returning successful lookup result: ${u}`),u}}y.logger=b.getLogger(y);class M{constructor(e=['"']){this.legalQuotes=e,this.pattern=this.generateMatcher()}parse(e){M.logger.debug(`Parsing input '${e}'`);const t=[],n=new RegExp(this.pattern);let s;for(;s=n.exec(e);){M.logger.trace(`Found match '${s}'`);const e=a(s.slice(1));e.length>0&&(M.logger.trace(`Found group '${e[0]}'`),t.push(e[0]))}return t}generateMatcher(){M.logger.debug("Creating matcher.");const e=this.legalQuotes.map(e=>`\\${e}`).map(e=>`${e}(.+?)${e}`);e.push("(\\S+)");let t;try{t=new RegExp(e.join("|"),"g")}catch(e){throw M.logger.error("The parsing pattern is invalid, this should never happen.",e),e}return t}}M.logger=b.getLogger(M);class C{constructor(e={},t={}){this.lookupResolver=new y(t.caseSensitive),this.inputParser=new M(t.legalQuotes),this.map=new c(e),this.mapAliased=new c,this.updateAliases()}setCommand(e,t){this.map.set(e,t),this.updateAliases()}getCommand(e){return this.mapAliased.get(e)}hasCommand(e){return this.mapAliased.has(e)}hasPath(e){return this.getPath(e).successful}getPath(e){return C.logger.debug(`Resolving pathUsed: ${e}`),this.lookupResolver.resolve(this.mapAliased,e)}parse(e){return C.logger.debug(`Parsing input: '${e}'`),this.lookupResolver.resolve(this.mapAliased,this.inputParser.parse(e),!0)}updateAliases(){C.logger.debug("Updating aliased map."),this.mapAliased.clear(),this.map.forEach((e,t)=>{this.mapAliased.set(t,e);e.alias.forEach(n=>{this.mapAliased.has(n)?C.logger.warn(`Alias '${n}' conflicts with a previously defined key, will be ignored.`):(C.logger.trace(`Created alias '${n}' for '${t}'`),this.mapAliased.set(n,e))})}),C.logger.debug("Done updating aliased map.")}}return C.loggerRoot=b,C.logger=b.getLogger(C),e.Clingy=C,e}({});
//# sourceMappingURL=clingy.min.js.map
