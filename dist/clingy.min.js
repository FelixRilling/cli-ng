var Clingy=function(){"use strict";!function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof module&&module.exports?module.exports=t():e.log=t()}(void 0,function(){function e(e,t){var n=e[t];if("function"==typeof n.bind)return n.bind(e);try{return Function.prototype.bind.call(n,e)}catch(t){return function(){return Function.prototype.apply.apply(n,[e,arguments])}}}function t(t){return"debug"===t&&(t="log"),typeof console!==a&&(void 0!==console[t]?e(console,t):void 0!==console.log?e(console,"log"):r)}function n(e,t){for(var n=0;n<u.length;n++){var o=u[n];this[o]=n<e?r:this.methodFactory(o,e,t)}this.log=this.debug}function o(e,t,o){return function(){typeof console!==a&&(n.call(this,t,o),this[e].apply(this,arguments))}}function i(e,n,i){return t(e)||o.apply(this,arguments)}function s(e,t,o){function s(e){var t=(u[e]||"silent").toUpperCase();if(typeof window!==a){try{return void(window.localStorage[g]=t)}catch(e){}try{window.document.cookie=encodeURIComponent(g)+"="+t+";"}catch(e){}}}function r(){var e;if(typeof window!==a){try{e=window.localStorage[g]}catch(e){}if(typeof e===a)try{var t=window.document.cookie,n=t.indexOf(encodeURIComponent(g)+"=");-1!==n&&(e=/^([^;]+)/.exec(t.slice(n))[1])}catch(e){}return void 0===c.levels[e]&&(e=void 0),e}}var l,c=this,g="loglevel";e&&(g+=":"+e),c.name=e,c.levels={TRACE:0,DEBUG:1,INFO:2,WARN:3,ERROR:4,SILENT:5},c.methodFactory=o||i,c.getLevel=function(){return l},c.setLevel=function(t,o){if("string"==typeof t&&void 0!==c.levels[t.toUpperCase()]&&(t=c.levels[t.toUpperCase()]),!("number"==typeof t&&t>=0&&t<=c.levels.SILENT))throw"log.setLevel() called with invalid level: "+t;if(l=t,!1!==o&&s(t),n.call(c,t,e),typeof console===a&&t<c.levels.SILENT)return"No console available for logging"},c.setDefaultLevel=function(e){r()||c.setLevel(e,!1)},c.enableAll=function(e){c.setLevel(c.levels.TRACE,e)},c.disableAll=function(e){c.setLevel(c.levels.SILENT,e)};var h=r();null==h&&(h=null==t?"WARN":t),c.setLevel(h,!1)}var r=function(){},a="undefined",u=["trace","debug","info","warn","error"],l=new s,c={};l.getLogger=function(e){if("string"!=typeof e||""===e)throw new TypeError("You must supply a name when creating a logger.");var t=c[e];return t||(t=c[e]=new s(e,l.getLevel(),l.methodFactory)),t};var g=typeof window!==a?window.log:void 0;return l.noConflict=function(){return typeof window!==a&&window.log===l&&(window.log=g),l},l.getLoggers=function(){return c},l});class e extends Map{hasIgnoreCase(e){return Array.from(this.keys()).map(e=>e.toLowerCase()).includes(e.toLowerCase())}getIgnoreCase(e){return this.forEach((t,n)=>{if(e.toLowerCase()===n.toLowerCase())return t}),null}}const t=e=>null==e,n=(e,t)=>{const n=e.length;const o=t.length;if(0===n)return o;if(0===o)return n;const i=[];for(let e=0;e<=o;e++)i[e]=[e];for(let e=0;e<=n;e++)i[0][e]=e;for(let s=1;s<=o;s++){const o=i[s],r=i[s-1];for(let i=1;i<=n;i++)if(t.charAt(s-1)===e.charAt(i-1))o[i]=r[i-1];else{const e=r[i-1]+1,t=o[i-1]+1,n=r[i]+1;o[i]=Math.min(e,t,n)}}return i[o][n]},o=(e,t)=>{const n=new Map;e.forEach((o,i)=>{const s=t(o,i,e);n.set(s,n.has(s)?[...n.get(s),o]:[o])});return n},i=(e,t,i=!1)=>{const s=o(t,t=>n(e,t));return i?s:s.get(Math.min(...s.keys()))};class s{constructor(e,t){this.missing=[],this.result=new Map;const n=(void 0)("ArgumentMatcher");n.debug("Matching arguments {} with {}",e,t),e.forEach((e,o)=>{o<t.length?(n.trace("Found matching argument for {}, adding to result: {}",e.name,t[o]),this.result.set(e.name,t[o])):e.required?(n.trace("No matching argument found for {}, adding to missing.",e.name),this.missing.push(e)):(n.trace("No matching argument found for {}, using default: {}",e.name,e.defaultValue),this.result.set(e.name,e.defaultValue))}),n.debug("Finished matching arguments: {} expected, {} found and {} missing.",e.length,this.result.size,this.missing.length)}}const r=(e,t)=>i(t,Array.from(e.keys()),!1);class a{constructor(e=!0){this.logger=(void 0)("LookupResolver"),this.caseSensitive=e}resolve(e,t,n=!1){return this.resolveInternal(e,t,[],n)}resolveInternal(e,n,o,i=!1){if(0===n.length)throw new Error("Path cannot be empty.");const a=n[0],u=n.slice(1);if(o.push(a),this.caseSensitive?!e.has(a):!e.hasIgnoreCase(a))return this.logger.warn("Command '{}' could not be found.",a),{successful:!1,pathUsed:o,pathDangling:u,type:1,missing:a,similar:r(e,a)};const l=this.caseSensitive?e.get(a):e.getIgnoreCase(a);this.logger.debug("Successfully looked up command: {}",a);let c;if(!i||t(l.args)||0===l.args.length)this.logger.debug("No arguments defined, using empty list."),c=new Map;else{this.logger.debug("Looking up arguments: {}",u);const e=new s(l.args,u);if(e.missing.length>0)return this.logger.warn("Some arguments could not be found: {}",e.missing),{successful:!1,pathUsed:o,pathDangling:u,type:2,missing:e.missing};c=e.result,this.logger.debug("Successfully looked up arguments: {}",c)}const g={successful:!0,pathUsed:o,pathDangling:u,type:0,command:l,args:c};return this.logger.debug("Returning successful lookup result: {}",g),g}}class u{constructor(e=['"']){this.logger=(void 0)("InputParser"),this.legalQuotes=e,this.pattern=this.generateMatcher()}static escapeRegexCharacter(e){return`\\Q${e}\\E`}parse(e){return this.logger.debug("Parsing input '{}'",e),Array.from(e.match(this.pattern))}generateMatcher(){this.logger.debug("Creating matcher.");const e=this.legalQuotes.map(u.escapeRegexCharacter).map(e=>`${e}(.+?)${e}`);e.push("(\\S+)");let t;try{t=new RegExp(e.join("|"),"")}catch(e){throw this.logger.error("The parsing pattern is invalid, this should never happen.",e),e}return t}}class l{constructor(t=new e,n=!0,o=['"']){this.logger=(void 0)("Clingy"),this.lookupResolver=new a(n),this.inputParser=new u(o),this.map=t,this.mapAliased=new e,this.updateAliases()}setCommand(e,t){this.map.set(e,t),this.updateAliases()}getCommand(e){return this.mapAliased.get(e)}hasCommand(e){return this.mapAliased.has(e)}hasPath(e){const t=this.getPath(e);return null!=t&&t.successful}getPath(e){return this.logger.debug("Resolving pathUsed: {}",e),this.lookupResolver.resolve(this.mapAliased,e)}parse(e){return this.logger.debug("Parsing input: '{}'",e),this.lookupResolver.resolve(this.mapAliased,this.inputParser.parse(e),!0)}updateAliases(){this.logger.debug("Updating aliased map."),this.mapAliased.clear(),this.map.forEach((e,t)=>{this.mapAliased.set(t,e);e.alias.forEach(n=>{this.mapAliased.has(n)?this.logger.warn("Alias '{}' conflicts with a previously defined key, will be ignored.",n):(this.logger.trace("Created alias '{}' for '{}'",n,t),this.mapAliased.set(n,e))})}),this.logger.debug("Done updating aliased map.")}}return l}();
//# sourceMappingURL=clingy.min.js.map
