var clingy=function(t){"use strict";class e extends Map{hasIgnoreCase(t){return Array.from(this.keys()).map(t=>t.toLowerCase()).includes(t.toLowerCase())}getIgnoreCase(t){let e=null;return this.forEach((n,s)=>{t.toLowerCase()===s.toLowerCase()&&(e=n)}),e}}var n;!function(t){t[t.ERROR=0]="ERROR",t[t.WARN=1]="WARN",t[t.INFO=2]="INFO",t[t.DEBUG=3]="DEBUG",t[t.TRACE=4]="TRACE"}(n||(n={}));let s=n.TRACE;const i=console,r=(t,e)=>`${(new Date).toISOString()} ${e} ${t} -`;class a{constructor(t){this.name=t}error(...t){s>=n.ERROR&&i.error(r(this.name,"ERROR"),...t)}warn(...t){s>=n.WARN&&i.warn(r(this.name,"WARN"),...t)}info(...t){s>=n.INFO&&i.info(r(this.name,"INFO"),...t)}debug(...t){s>=n.DEBUG&&i.log(r(this.name,"DEBUG"),...t)}trace(...t){s>=n.TRACE&&i.log(r(this.name,"TRACE"),...t)}}const o={level:s,getLogger:t=>new a("name"in t?t.name:t)},g=t=>null==t,u=(t,e)=>{const n=t.length;const s=e.length;if(0===n)return s;if(0===s)return n;const i=[];for(let t=0;t<=s;t++)i[t]=[t];for(let t=0;t<=n;t++)i[0][t]=t;for(let r=1;r<=s;r++){const s=i[r],a=i[r-1];for(let i=1;i<=n;i++)if(e.charAt(r-1)===t.charAt(i-1))s[i]=a[i-1];else{const t=a[i-1]+1,e=s[i-1]+1,n=a[i]+1;s[i]=Math.min(t,e,n)}}return i[s][n]},h=(t,e)=>{const n=new Map;t.forEach((s,i)=>{const r=e(s,i,t);n.set(r,n.has(r)?[...n.get(r),s]:[s])});return n},l=(t,e,n=!1)=>{const s=h(e,e=>u(t,e));return n?s:s.get(Math.min(...s.keys()))};class c{constructor(t,e){this.missing=[],this.result=new Map;const n=o.getLogger(c);n.debug(`Matching arguments ${t} with ${e}`),t.forEach((t,s)=>{if(s<e.length){const i=e[s];n.trace(`Found matching argument for ${t.name}, adding to result: ${i}`),this.result.set(t.name,i)}else t.required||null==t.defaultValue?(n.trace(`No matching argument found for ${t.name}, adding to missing.`),this.missing.push(t)):(n.trace(`No matching argument found for ${t.name}, using default: ${t.defaultValue}`),this.result.set(t.name,t.defaultValue))}),n.debug(`Finished matching arguments: ${t.length} expected, ${this.result.size} found and ${this.missing.length} missing.`)}}const f=(t,e)=>l(e,Array.from(t.keys()),!1);class p{constructor(t=!0){this.logger=o.getLogger(p),this.caseSensitive=t}resolve(t,e,n=!1){return this.resolveInternal(t,e,[],n)}resolveInternal(t,e,n,s=!1){if(0===e.length)throw new Error("Path cannot be empty.");const i=e[0],r=e.slice(1);if(n.push(i),this.caseSensitive?!t.has(i):!t.hasIgnoreCase(i))return this.logger.warn(`Command '${i}' could not be found.`),{successful:!1,pathUsed:n,pathDangling:r,type:1,missing:i,similar:f(t,i)};const a=this.caseSensitive?t.get(i):t.getIgnoreCase(i);this.logger.debug(`Successfully looked up command: ${i}`);let o;if(!s||g(a.args)||0===a.args.length)this.logger.debug("No arguments defined, using empty list."),o=new Map;else{this.logger.debug(`Looking up arguments: ${r}`);const t=new c(a.args,r);if(t.missing.length>0)return this.logger.warn(`Some arguments could not be found: ${t.missing}`),{successful:!1,pathUsed:n,pathDangling:r,type:2,missing:t.missing};o=t.result,this.logger.debug(`Successfully looked up arguments: ${o}`)}const u={successful:!0,pathUsed:n,pathDangling:r,type:0,command:a,args:o};return this.logger.debug(`Returning successful lookup result: ${u}`),u}}class m{constructor(t=['"']){this.logger=o.getLogger(m),this.legalQuotes=t,this.pattern=this.generateMatcher()}parse(t){return this.logger.debug("Parsing input '{}'",t),Array.from(t.match(this.pattern))}generateMatcher(){this.logger.debug("Creating matcher.");const t=this.legalQuotes.map(t=>`\\Q${t}\\E`).map(t=>`${t}(.+?)${t}`);t.push("(\\S+)");let e;try{e=new RegExp(t.join("|"),"")}catch(t){throw this.logger.error("The parsing pattern is invalid, this should never happen.",t),t}return e}}class d{constructor(t=new Map,n=!0,s=['"']){this.logger=o.getLogger(d),this.lookupResolver=new p(n),this.inputParser=new m(s),this.map=new e(t),this.mapAliased=new e,this.updateAliases()}setCommand(t,e){this.map.set(t,e),this.updateAliases()}getCommand(t){return this.mapAliased.get(t)}hasCommand(t){return this.mapAliased.has(t)}hasPath(t){const e=this.getPath(t);return null!=e&&e.successful}getPath(t){return this.logger.debug(`Resolving pathUsed: ${t}`),this.lookupResolver.resolve(this.mapAliased,t)}parse(t){return this.logger.debug(`Parsing input: '${t}'`),this.lookupResolver.resolve(this.mapAliased,this.inputParser.parse(t),!0)}updateAliases(){this.logger.debug("Updating aliased map."),this.mapAliased.clear(),this.map.forEach((t,e)=>{this.mapAliased.set(e,t);t.alias.forEach(n=>{this.mapAliased.has(n)?this.logger.warn(`Alias '${n}' conflicts with a previously defined key, will be ignored.`):(this.logger.trace(`Created alias '${n}' for '${e}'`),this.mapAliased.set(n,t))})}),this.logger.debug("Done updating aliased map.")}}return t.Clingy=d,t}({});
//# sourceMappingURL=clingy.min.js.map
