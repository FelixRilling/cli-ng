var clingy=function(e){"use strict";const t=(e,...t)=>t.some(t=>e instanceof t),s=(e,...t)=>t.some(t=>typeof e===t),r=e=>null==e,n=(e,t)=>{for(const[s,r]of Object.entries(e))t(r,s,e)},a=e=>t(e,Map),o=e=>(e=>!r(e)&&s(e,"object"))(e)||(e=>s(e,"function"))(e),i=e=>o(e)&&e.constructor===Object,l=e=>(e=>s(e,"string"))(e)?e:o(e)&&!r(e.name)?e.name:(e=>s(e,"symbol"))(e)&&!r(e.description)?e.description:null,g=e=>e.filter(e=>e),u=(e,t,s=!1)=>{const n=((e,t)=>{const s=new Map;return e.forEach((n,a)=>{const o=t(n,a,e);r(o)||s.set(o,s.has(o)?[...s.get(o),n]:[n])}),s})(t,t=>((e,t)=>{if(0===e.length)return t.length;if(0===t.length)return e.length;const s=[];for(let e=0;e<=t.length;e++)s[e]=[e];for(let t=0;t<=e.length;t++)s[0][t]=t;for(let r=1;r<=t.length;r++){const n=s[r],a=s[r-1];for(let s=1;s<=e.length;s++)if(t.charAt(r-1)===e.charAt(s-1))n[s]=a[s-1];else{const e=a[s-1]+1,t=n[s-1]+1,r=a[s]+1;n[s]=Math.min(e,t,r)}}return s[t.length][e.length]})(e,t));return s?n:n.get(Math.min(...n.keys()))};class h extends Map{constructor(e){super(h.getConstructorMap(e))}static createWithOptions(e,t){return a(e)?e.forEach(e=>h.createWithOptionsHelper(e,t)):i(e)&&n(e,e=>h.createWithOptionsHelper(e,t)),new h(e)}static createWithOptionsHelper(e,t){(i(e.sub)||a(e.sub))&&(e.sub=new A(h.createWithOptions(e.sub,t),t))}static getConstructorMap(e){return a(e)?Array.from(e.entries()):o(e)?Array.from(Object.entries(e)):null}hasCommand(e,t){return 1===t?Array.from(this.keys()).map(e=>e.toLowerCase()).includes(e.toLowerCase()):this.has(e)}getCommand(e,t){if(1===t){let t=null;return this.forEach((s,r)=>{e.toLowerCase()===r.toLowerCase()&&(t=s)}),t}return this.has(e)?this.get(e):null}}const c={NONE:{val:-1},ERROR:{name:"ERROR",val:0},WARN:{name:"WARN",val:1},INFO:{name:"INFO",val:2},DEBUG:{name:"DEBUG",val:3},TRACE:{name:"TRACE",val:4}},m=(e,t,s)=>{let r=console.log;t===c.ERROR?r=console.error:t===c.WARN?r=console.warn:t===c.INFO&&(r=console.info),r(((e,t)=>`${(new Date).toISOString()} ${t.name} ${e}`)(e,t),...s)},d=(e,t)=>e.val<=t.val;class p{constructor(e,t){this.root=e,this.name=t}log(e,...t){this.root.level.val>=e.val&&this.root.appenders.forEach(s=>s(this.name,e,t))}error(...e){this.log(c.ERROR,...e)}warn(...e){this.log(c.WARN,...e)}info(...e){this.log(c.INFO,...e)}debug(...e){this.log(c.DEBUG,...e)}trace(...e){this.log(c.TRACE,...e)}isError(){return d(c.ERROR,this.root.level)}isWarn(){return d(c.WARN,this.root.level)}isInfo(){return d(c.INFO,this.root.level)}isDebug(){return d(c.DEBUG,this.root.level)}isTrace(){return d(c.TRACE,this.root.level)}}const f=new class{constructor(){this.loggers=new Map,this.appenders=new Set([m]),this.level=c.INFO}getLogger(e){const t=l(e);if(null==t)throw new TypeError(`'${e}' is neither an INameable nor a string.`);if(!this.loggers.has(t)){const e=new p(this,t);this.loggers.set(t,e)}return this.loggers.get(t)}};class b{constructor(e,t){this.missing=[],this.result=new Map,b.logger.debug("Matching arguments:",e,t),e.forEach((e,s)=>{if(s<t.length){const r=t[s];b.logger.trace(`Found matching argument for ${e.name}, adding to result: ${r}`),this.result.set(e.name,r)}else e.required?(b.logger.trace(`No matching argument found for ${e.name}, adding to missing.`),this.missing.push(e)):r(e.defaultValue)?(b.logger.trace(`No matching argument found for ${e.name}, using null.`),this.result.set(e.name,null)):(b.logger.trace(`No matching argument found for ${e.name}, using default: ${e.defaultValue}`),this.result.set(e.name,e.defaultValue))}),b.logger.debug(`Finished matching arguments: ${e.length} expected, ${this.result.size} found and ${this.missing.length} missing.`)}}b.logger=f.getLogger(b);const v=(e,t)=>u(t,Array.from(e.keys()),!1);class R{constructor(e=!0){this.caseSensitivity=e?0:1}static createSuccessResult(e,t,s,r){const n={successful:!0,pathUsed:t,pathDangling:e,type:0,command:s,args:r};return R.logger.debug("Returning successful lookup result:",n),n}static createNotFoundResult(e,t,s,r){return R.logger.warn(`Command '${s}' could not be found.`),{successful:!1,pathUsed:t,pathDangling:e,type:1,missing:s,similar:v(r,s)}}static createMissingArgsResult(e,t,s){return R.logger.warn("Some arguments could not be found:",s),{successful:!1,pathUsed:t,pathDangling:e,type:2,missing:s}}resolve(e,t,s){if(0===t.length)throw new Error("Path cannot be empty.");return this.resolveInternal(e,t,[],s)}resolveInternal(e,s,n,a){const o=s[0],i=s.slice(1);if(n.push(o),!this.hasCommand(e,o))return R.createNotFoundResult(i,n,o,e);const l=e.getCommand(o,this.caseSensitivity);if(R.logger.debug(`Found command: '${o}'.`),i.length>0&&t(l.sub,A)&&this.hasCommand(l.sub.mapAliased,i[0]))return this.resolveInternalSub(i,n,l,a);let g;if(1===a||r(l.args)||0===l.args.length)R.logger.debug("No arguments defined, using empty map."),g=new Map;else{R.logger.debug(`Looking up arguments: '${i}'.`);const e=new b(l.args,i);if(e.missing.length>0)return R.createMissingArgsResult(i,n,e.missing);g=e.result,R.logger.debug("Successfully looked up arguments: ",g)}return R.createSuccessResult(i,n,l,g)}resolveInternalSub(e,t,s,r){return R.logger.debug("Resolving sub-commands:",s.sub,e),this.resolveInternal(s.sub.mapAliased,e,t,r)}hasCommand(e,t){return e.hasCommand(t,this.caseSensitivity)}}R.logger=f.getLogger(R);class w{constructor(e=['"']){this.legalQuotes=e,this.pattern=this.generateMatcher()}parse(e){w.logger.debug(`Parsing input '${e}'`);const t=[],s=new RegExp(this.pattern);let r;for(;r=s.exec(e);){w.logger.trace(`Found match '${r}'`);const e=g(r.slice(1));e.length>0&&(w.logger.trace(`Found group '${e[0]}'`),t.push(e[0]))}return t}generateMatcher(){w.logger.debug("Creating matcher.");const e=this.legalQuotes.map(e=>`\\${e}`).map(e=>`${e}(.+?)${e}`);let t;e.push("(\\S+)");try{t=new RegExp(e.join("|"),"g")}catch(e){throw w.logger.error("The parsing pattern is invalid, this should never happen.",e),e}return t}}w.logger=f.getLogger(w);class A{constructor(e={},t={}){this.lookupResolver=new R(t.caseSensitive),this.inputParser=new w(t.legalQuotes),this.map=h.createWithOptions(e,t),this.mapAliased=new h,this.updateAliases()}setCommand(e,t){this.map.set(e,t),this.updateAliases()}getCommand(e){return this.mapAliased.get(e)}hasCommand(e){return this.mapAliased.has(e)}hasPath(e){return this.getPath(e).successful}getPath(e){return A.logger.debug(`Resolving pathUsed: ${e}`),this.lookupResolver.resolve(this.mapAliased,e,1)}parse(e){return A.logger.debug(`Parsing input: '${e}'`),this.lookupResolver.resolve(this.mapAliased,this.inputParser.parse(e),0)}updateAliases(){A.logger.debug("Updating aliased map."),this.mapAliased.clear(),this.map.forEach((e,t)=>{this.mapAliased.set(t,e),e.alias.forEach(s=>{this.mapAliased.has(s)?A.logger.warn(`Alias '${s}' conflicts with a previously defined key, will be ignored.`):(A.logger.trace(`Created alias '${s}' for '${t}'`),this.mapAliased.set(s,e))})}),A.logger.debug("Done updating aliased map.")}}return A.logger=f.getLogger(A),e.Clingy=A,e.clingyLogby=f,e}({});
//# sourceMappingURL=clingy.min.js.map
