<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>clingy.esm.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Clingy.html">Clingy</a><ul class='methods'><li data-type='method'><a href="Clingy.html#getAll">getAll</a></li><li data-type='method'><a href="Clingy.html#getCommand">getCommand</a></li><li data-type='method'><a href="Clingy.html#parse">parse</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">clingy.esm.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { isString, objDefaults, objDefaultsDeep } from 'lightdash';
import similar from 'similar-strings';

/**
 * Default argument structure
 *
 * @private
 * @param {Object} arg
 * @param {number} index
 * @returns {Object}
 */
const argDefaultFactory = (index) => {
    return {
        name: `arg${index}`,
        required: true,
        default: null
    };
};

/**
 * Default command structure
 *
 * @private
 * @param {Object} arg
 * @param {number} index
 * @returns {Object}
 */
const commandDefaultFactory = (index) => {
    return {
        name: `command${index}`,
        fn: () => { },
        alias: [],
        args: [],
        sub: null
    };
};

/**
 * Creates an aliased map from a normal map
 *
 * @private
 * @param {Map} map
 * @returns {Map}
 */
const getAliasedMap = (map) => {
    const result = new Map(map);
    map.forEach((command) => {
        command.alias.forEach((alias) => {
            if (result.has(alias)) {
                throw new Error(`Alias ${alias} conflicts with a previously defined key`);
            }
            else {
                result.set(alias, command);
            }
        });
    });
    return result;
};

/**
 * Matches command-map arguments with input args
 *
 * @private
 * @param {Array&lt;Object>} expectedArgs
 * @param {Array&lt;Object>} givenArgs
 * @returns {Object}
 */
const mapArgs = (expectedArgs, givenArgs) => {
    const result = {
        args: {
            _all: givenArgs // Special arg that contains all other args
        },
        missing: []
    };
    expectedArgs.forEach((expectedArg, index) => {
        const givenArg = givenArgs[index];
        if (givenArg) {
            // Arg exists
            result.args[expectedArg.name] = givenArg;
        }
        else {
            // Arg doesn't exist
            if (!expectedArg.required) {
                // Use default value
                result.args[expectedArg.name] = expectedArg.default;
            }
            else {
                // Mark as missing
                result.missing.push(expectedArg);
            }
        }
    });
    return result;
};

const SPACE = /\s/;
/**
 * Parses a string into an Array while supporting quoted strings
 *
 * @private
 * @param {string} str
 * @param {Array&lt;string>} validQuotes
 * @returns {Array&lt;string>}
 */
const splitWithQuotedStrings = (str, validQuotes) => {
    const result = [];
    let partStr = [];
    let inString = false;
    str.split("").forEach((letter, index) => {
        const isSpace = SPACE.test(letter);
        if (validQuotes.includes(letter)) {
            // Toggle inString once a quote is encountered
            inString = !inString;
        }
        else if (inString || !isSpace) {
            // Push everything thats not a quote or a space(if outside quotes)
            partStr.push(letter);
        }
        if ((partStr.length > 0 &amp;&amp; isSpace &amp;&amp; !inString) ||
            index === str.length - 1) {
            // Push current arg to container
            result.push(partStr.join(""));
            partStr = [];
        }
    });
    return result;
};
/**
 * Parses a string into an Array
 *
 * @private
 * @param {string} strInput
 * @param {Array&lt;string>|null} validQuotes
 * @returns {Array&lt;string>}
 */
const parseString = (strInput, validQuotes) => {
    const str = strInput.trim();
    // Only use the 'complex' algorithm if allowQuotedStrings is true
    return validQuotes !== null
        ? splitWithQuotedStrings(str, validQuotes)
        : str.split(SPACE);
};

const optionsDefault = {
    /**
     * If names should be treated case-sensitive for lookup
     */
    caseSensitive: true,
    /**
     * List of characters to allow as quote-enclosing string
     * If set to null, quotes-enclosed strings will be disabled
     */
    validQuotes: ['"']
};
/**
 * Creates a map and sub-maps out of a command object
 *
 * @private
 * @param {Array&lt;IClingyCommand>} commandEntries
 * @returns {Map}
 */
const mapCommands = (commandEntries, caseSensitive) => new Map(commandEntries.map((command, index) => {
    if (!isString(command[0])) {
        throw new TypeError(`command key '${command[0]}' is not a string`);
    }
    const commandKey = caseSensitive
        ? command[0]
        : command[0].toLowerCase();
    const commandValue = objDefaultsDeep(command[1], commandDefaultFactory(index));
    // Save key as name property to keep track in aliases
    commandValue.name = commandKey;
    // Merge each arg with default arg structure
    commandValue.args = commandValue.args.map((arg, argIndex) => objDefaults(arg, argDefaultFactory(argIndex)));
    // If sub-groups exist, recurse by creating a new Clingy instance
    if (commandValue.sub !== null) {
        commandValue.sub = new Clingy(commandValue.sub);
    }
    return [commandKey, commandValue];
}));
/**
 * Clingy class
 *
 * @class
 */
const Clingy = class {
    /**
     * Creates Clingy instance
     *
     * @constructor
     * @param {Object} commands
     * @param {Object} options
     */
    constructor(commands = {}, options = {}) {
        this.options = objDefaultsDeep(options, optionsDefault);
        this.map = mapCommands(Object.entries(commands), this.options.caseSensitive);
        this.mapAliased = getAliasedMap(this.map);
    }
    /**
     * Returns all instance maps
     *
     * @returns {Object}
     */
    getAll() {
        return {
            map: this.map,
            mapAliased: this.mapAliased
        };
    }
    /**
     * Looks up a command by path
     *
     * @param {Array&lt;string>} path
     * @param {Array&lt;string>} [pathUsed=[]]
     * @returns {Object}
     */
    getCommand(path, pathUsed = []) {
        if (path.length &lt; 1) {
            throw new Error("Path does not contain at least one item");
        }
        const commandNameCurrent = this.options.caseSensitive
            ? path[0]
            : path[0].toLowerCase();
        const pathUsedNew = pathUsed;
        if (!this.mapAliased.has(commandNameCurrent)) {
            return {
                success: false,
                error: {
                    type: "missingCommand",
                    missing: [commandNameCurrent],
                    similar: similar(commandNameCurrent, Array.from(this.mapAliased.keys()))
                },
                path: pathUsedNew
            };
        }
        const command = this.mapAliased.get(commandNameCurrent);
        const commandPathNew = path.slice(1);
        pathUsedNew.push(commandNameCurrent);
        // Recurse into sub if more items in path and sub exists
        if (path.length > 1 &amp;&amp; command.sub !== null) {
            const commandSubResult = command.sub.getCommand(commandPathNew, pathUsedNew);
            if (commandSubResult.success) {
                return commandSubResult;
            }
        }
        return {
            success: true,
            command,
            path: pathUsedNew,
            pathDangling: commandPathNew
        };
    }
    /**
     * Parses a CLI-like input string into command and args
     *
     * @param {string} input
     * @returns {Object}
     */
    parse(input) {
        const inputParsed = parseString(input, this.options.validQuotes);
        const commandLookup = this.getCommand(inputParsed);
        if (!commandLookup.success) {
            // Error: Command not found
            return commandLookup;
        }
        const command = commandLookup.command;
        const args = commandLookup.pathDangling;
        const argsMapped = mapArgs(command.args, args);
        if (argsMapped.missing.length !== 0) {
            // Error: Missing arguments
            return {
                success: false,
                error: {
                    type: "missingArg",
                    missing: argsMapped.missing
                }
            };
        }
        commandLookup.args = argsMapped.args;
        // Success
        return commandLookup;
    }
};

export default Clingy;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.0-dev</a> on Mon Mar 26 2018 20:15:40 GMT+0200 (CEST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
